<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一只特立独行的鸟">
<meta property="og:type" content="website">
<meta property="og:title" content="一只特立独行的鸟">
<meta property="og:url" content="http://kuring.me/page/8/index.html">
<meta property="og:site_name" content="一只特立独行的鸟">
<meta property="og:description" content="一只特立独行的鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一只特立独行的鸟">
<meta name="twitter:description" content="一只特立独行的鸟">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kuring.me/page/8/"/>





  <title> 一只特立独行的鸟 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一只特立独行的鸟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">分享我的学习心得，记录我的学习笔记。趁着年轻多学点东西总是正确的~~~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/my_data_bak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/my_data_bak/" itemprop="url">
                  我的个人数据备份方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-09-16T18:33:32+08:00">
                2013-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>没有一成不坏的硬件，尤其是数据放到物理硬盘中，说不定哪天硬盘闹脾气就崩掉了，硬盘不值钱，可是里面的数据值钱。下面分享下我的数据备份方案，我的原则是数据无论何时都至少留有一个备份。</p>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>我的博客是放到Dropbox中的，在云端和本地均有备份，确保了博客数据的绝对安全，即使云端坏掉还有本地，本地丢了还有云端。</p>
<h1 id="个人照片"><a href="#个人照片" class="headerlink" title="个人照片"></a>个人照片</h1><p>由于照片都较大，放到本地硬盘很容易占满空间，而且还不经常用。除了在自己电脑上留有照片之外，选择将照片压缩并加密后按照年份放到百度云上。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>工作几年了，已经积攒了一些代码，有些代码时不时的会查看到。对于可以公开的自己写的代码我以后打算放到我的Github上，一方面是由于Github上可以在线浏览代码，另一方面可以向别人分享我的代码。<br>对于私有的代码，暂时放到了金山快盘上，没有找到可以方便浏览代码的云端。</p>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>由于文档之类的资料也是经常用到，我选择了金山快盘。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/linux_windows_network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/linux_windows_network/" itemprop="url">
                  Linux和Windows平台下的网络通信问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-09-15T10:41:25+08:00">
                2013-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大小端问题跟CPU的架构直接相关，我们常见的80x86系列CPU采用小端字节序模式。Windows平台就采用的80x86系列CPU，因此为小端字节序。<br>而主机之间进行网络通信时往往采用大端字节序，因此小端字节序机器在发送数据前需要进行字节序转换，在接收到数据处理处理数据之前要将网络字节序转换成本地字节序。</p>
<p>在Linux平台下提供了四个函数用来字节序转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">uint32_t htonl(uint32_t hostlong);</div><div class="line">uint16_t htons(uint16_t hostshort);</div><div class="line">uint32_t ntohl(uint32_t netlong);</div><div class="line">uint16_t ntohs(uint16_t netshort);</div></pre></td></tr></table></figure></p>
<p>Windows平台下也提供了相关的自己序转换函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;WinSock2.h&gt;</div><div class="line">unsigned __int64 __inline htond(</div><div class="line">  double value</div><div class="line">);</div><div class="line"></div><div class="line">unsigned __int32 __inline htonf(</div><div class="line">  float value</div><div class="line">);</div><div class="line"></div><div class="line">u_long WSAAPI htonl(</div><div class="line">  _In_  u_long hostlong</div><div class="line">);</div><div class="line"></div><div class="line">unsigned __int64 __inline htonll(</div><div class="line">  unsigned __int64 value</div><div class="line">);</div><div class="line"></div><div class="line">u_short WSAAPI htons(</div><div class="line">  _In_  u_short hostshort</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line">double __inline ntohd(</div><div class="line">  unsigned __int64 value</div><div class="line">);</div><div class="line"></div><div class="line">float __inline ntohf(</div><div class="line">  unsigned __int32 value</div><div class="line">);</div><div class="line"></div><div class="line">u_long WSAAPI ntohl(</div><div class="line">  _In_  u_long netlong</div><div class="line">);</div><div class="line"></div><div class="line">u_long __inline ntohll(</div><div class="line">  unsigned __int64 value</div><div class="line">);</div><div class="line"></div><div class="line">u_short WSAAPI ntohs(</div><div class="line">  _In_  u_short netshort</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>这里有个技巧需要说明以下，比如要发送如下的结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct foo</div><div class="line">&#123;</div><div class="line">    int a;</div><div class="line">    long b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>为了避免每个成员都调用字节序转换函数，可以在结构体的内部定义两个方法用于转换字节序，添加字节序后的foo如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct foo</div><div class="line">&#123;</div><div class="line">    int a;</div><div class="line">    long b;</div><div class="line">    void ntoh()</div><div class="line">    &#123;</div><div class="line">         a = ntohl(a);</div><div class="line">         b = ntohl(b);</div><div class="line">    &#125;</div><div class="line">    void hton()</div><div class="line">    &#123;</div><div class="line">         a = htonl(a);</div><div class="line">         b = htonl(b);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>需要特别注意的是，在发送结构体类型的数据时要注意字节对齐的问题，这里不再展开讨论，不同的平台有不同的解决办法。大体分为Winodws平台、AIX平台和GNU类平台。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/parse_http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/parse_http/" itemprop="url">
                  两个通过http获取指定网页内容并解析的简单程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-09-02T19:03:43+08:00">
                2013-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近段时间写了两个通过http协议来获取指定网页的内容并将内容解析出来的程序。程序一可以解析出目前本博客的内容页面的内容、时间、访问次数参数，采用Qt类库实现；程序二可以解析出新浪博客页面的内容、时间等参数，采用Linux下的tcp相关API实现。均采用C++语言实现。</p>
<h1 id="程序一"><a href="#程序一" class="headerlink" title="程序一"></a>程序一</h1><p>该程序采用Qt类库实现，其中Http协议的发送和接收采用Qt类库封装的类，网页内容的解析采用Qt封装的解析XML的相关类。<br>该程序仅能解析标准的Html语言，对于网页中的所有”&lt;&gt;”标签必须有结尾才行。例如本页面源码中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>必须是闭合的。如果是下面这样则无法正确解析网页内容，这是由于采用的Qt类库决定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;</div></pre></td></tr></table></figure></p>
<h1 id="程序二"><a href="#程序二" class="headerlink" title="程序二"></a>程序二</h1><p>该程序的Http协议部分采用Linux的tcp协议api实现，解析网页直接采用搜索字符串的方式实现，较上一种方式要底层，仅能运行在Linux系统下运行。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/share/link?shareid=1578018382&amp;uk=3506813023" target="_blank" rel="external">程序一和二的下载链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/vim_plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/vim_plugin/" itemprop="url">
                  vim插件安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-09-02T13:19:16+08:00">
                2013-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文的安装环境为ubuntu13.04。为了以后便于查阅，本文将相关插件的使用放到了文章的开始部分。这里不作插件的相关介绍，相关介绍看文章底部的参考文章。</p>
<h1 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h1><p>本插件快捷键会跟随下文安装内容一块同步。</p>
<h2 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h2><p>在源码目录执行<code>ctags -R</code>可生成ctags文件。该文件在源码修改后并不会改变，需要重新生成ctags文件。<br>ctrl+]：转到函数定义处。<br>ctrl+T：回到执行<code>ctrl+]</code>的地方。</p>
<h2 id="taglist"><a href="#taglist" class="headerlink" title="taglist"></a>taglist</h2><p><code>:TlistOpen</code>：打开taglist窗口<br><code>:TlistClose</code>：关闭taglist窗口。<br><code>:TlistToggle</code>：在打开和关闭间切换。</p>
<h2 id="NERD-tree"><a href="#NERD-tree" class="headerlink" title="NERD tree"></a>NERD tree</h2><p><code>:NERDTree</code>：打开窗口。</p>
<h2 id="winmanager"><a href="#winmanager" class="headerlink" title="winmanager"></a>winmanager</h2><p><code>wm</code>：打开和关闭taglist和NERD tree窗口。</p>
<h2 id="a-vim"><a href="#a-vim" class="headerlink" title="a.vim"></a>a.vim</h2><p><code>:A</code>：在新Buffer中切换到c/h文件<br><code>:AS</code>：横向分割窗口并打开c/h文件<br><code>:AV</code>：纵向分割窗口并打开c/h文件<br><code>:AT</code>：新建一个标签页并打开c/h文件<br><code>F12</code>：代替<code>:A</code>命令</p>
<h2 id="MiniBufExplorer"><a href="#MiniBufExplorer" class="headerlink" title="MiniBufExplorer"></a>MiniBufExplorer</h2><p><code>&lt;Tab&gt;</code>：向前循环切换到每个buffer名上<br><code>&lt;S-Tab&gt;</code>：向后循环切换到每个buffer名上<br><code>&lt;Enter&gt;</code>：在打开光标所在的buffer<br><code>d</code>：删除光标所在的buffer</p>
<h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><h2 id="安装ctags"><a href="#安装ctags" class="headerlink" title="安装ctags"></a>安装ctags</h2><p>执行： <code>sudo apt-get install ctags</code>。</p>
<h2 id="安装taglist"><a href="#安装taglist" class="headerlink" title="安装taglist"></a>安装taglist</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=273。下载后得到taglist_46.zip文件。" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=273。下载后得到taglist_46.zip文件。</a></li>
<li>执行<code>unzip taglist_46.zip</code>解压文件。</li>
<li>将解压出的文件复制到~/.vim目录下。<code>sudo cp ~/tmp/ ~/.vim/</code>。</li>
<li>在~/.vimrc文件中添加如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let Tlist_Show_One_File = 1            &quot;不同时显示多个文件的tag，只显示当前文件的</div><div class="line">let Tlist_Exit_OnlyWindow = 1          &quot;如果taglist窗口是最后一个窗口，则退出vim</div><div class="line">let Tlist_Use_Right_Window = 1         &quot;在右侧窗口中显示</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参考网址：<a href="http://www.cnblogs.com/mo-beifeng/archive/2011/11/22/2259356.html" target="_blank" rel="external">http://www.cnblogs.com/mo-beifeng/archive/2011/11/22/2259356.html</a></p>
<h2 id="安装文件浏览器NERD-tree"><a href="#安装文件浏览器NERD-tree" class="headerlink" title="安装文件浏览器NERD tree"></a>安装文件浏览器NERD tree</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=1658。" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1658。</a></li>
<li>将下载后的nerdtree.zip文件解压到~/.vim目录下。 </li>
</ol>
<h2 id="安装winmanager"><a href="#安装winmanager" class="headerlink" title="安装winmanager"></a>安装winmanager</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=95" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=95</a></li>
<li>将下载后的winmanager.zip文件解压到~/.vim目录下</li>
<li>修改.vimrc文件，添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let g:winManagerWindowLayout=&apos;FileExplorer|TagList&apos;</div><div class="line">nmap wm :WMToggle&lt;cr&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样利用winmanager工具将taglist和NERD tree工具整合到了一个块，输入wm可以打开和关闭窗口。</p>
<h2 id="安装cscope"><a href="#安装cscope" class="headerlink" title="安装cscope"></a>安装cscope</h2><ol>
<li>下载页面：<a href="http://cscope.sourceforge.net，下载后得到文件cscope-15.8a.tar.gz。" target="_blank" rel="external">http://cscope.sourceforge.net，下载后得到文件cscope-15.8a.tar.gz。</a></li>
<li>./configure</li>
<li>make。可能会出现错误，执行如下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get install libncurses-dev</div><div class="line">sudo apt-get install flex</div><div class="line">sudo apt-get install byacc</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后执行<code>make clean</code>后重新make。</p>
<ol>
<li>sudo make install</li>
</ol>
<h2 id="安装在h-c文件之间切换插件a-vim"><a href="#安装在h-c文件之间切换插件a-vim" class="headerlink" title="安装在h/c文件之间切换插件a.vim"></a>安装在h/c文件之间切换插件a.vim</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=31。" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=31。</a></li>
<li>将下载的a.vim文件复制到~/.vim/plugin文件夹下。</li>
<li>在~/.vimrc文件中添加<code>nnoremap &lt;silent&gt; &lt;F12&gt; :A&lt;CR&gt;</code></li>
<li>下面内容为快捷键列表：<br>:A switches to the header file corresponding to the current file being edited (or vise versa)<br>:AS splits and switches<br>:AV vertical splits and switches<br>:AT new tab and switches<br>:AN cycles through matches<br>:IH switches to file under cursor<br>:IHS splits and switches<br>:IHV vertical splits and switches<br>:IHT new tab and switches<br>:IHN cycles through matches<br><leader>ih switches to file under cursor<br><leader>is switches to the alternate file of file under cursor (e.g. on  <foo.h> switches to foo.cpp)<br><leader>ihn cycles through matches</leader></foo.h></leader></leader></li>
</ol>
<h2 id="安装快速浏览和操作Buffer"><a href="#安装快速浏览和操作Buffer" class="headerlink" title="安装快速浏览和操作Buffer"></a>安装快速浏览和操作Buffer</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=159" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=159</a></li>
<li>将下载的 minibufexpl.vim文件丢到 ~/.vim/plugin 文件夹中即可</li>
<li><p>在~/.vimrc文件中增加如下行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let g:miniBufExplMapCTabSwitchBufs = 1</div><div class="line">let g:miniBufExplMapWindowNavVim = 1</div><div class="line">let g:miniBufExplMapWindowNavArrows = 1</div></pre></td></tr></table></figure>
</li>
<li><p>快捷键：<br><tab>    向前循环切换到每个buffer名上<br><s-tab>    向后循环切换到每个buffer名上<br><enter>    在打开光标所在的buffer<br>d    删除光标所在的buffer</enter></s-tab></tab></p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/tge7618291/article/details/4216977" target="_blank" rel="external">经典vim插件功能说明、安装方法和使用方法介绍</a></li>
<li><a href="http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="external">手把手教你把Vim改装成一个IDE编程环境</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/mayor_hotline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/mayor_hotline/" itemprop="url">
                  市长热线12345
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-08-23T12:01:20+08:00">
                2013-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/ref/life/mayor_hotline.jpg" alt="Image Title"></p>
<p>前段时间在家看书学习，难得的学习的好时机。</p>
<p>楼下有一个卖饭的小摊及其猖狂，不仅占用了人行道来炒菜，而且还在马路上摆了一溜桌子供客人吃饭，不仅占用了人行道，连车行道都给占用了。这些也就罢了，对我影响都不算太大，更可气的是每天中午和晚上吃饭的时候会开着大音响放着恼人的音乐，我不想惹麻烦，我忍。</p>
<p>今天中午我刚开始看书，看到难处需要精心思考，恼人的音乐又开始了，我实在忍不住了，TMD，维权。打市长热线12345投诉，市长热线让我打110投诉。继续打110投诉，然后跟110说了下具体情况后，说给相应的派出所去处理。派出所的小片警立刻就给我回电话了，说外放音乐正常经营范围，只要不在晚上或清晨放音乐就不算违规，他们管不着，建议我去下面跟卖饭的商量，好一个商量。然后我又说，他们非法占道经营，小片警又说这个归城管管，让我给城管打电话，好一个给城管打电话。好一个推卸责任，这些把我给惹毛了。</p>
<p>挂断电话后，寻思这个理不太对，然后继续给市长热线12345打电话，告诉情况后，市长热线的妹子告诉我说这个事情我给你处理，好一个我给你处理，这才是为人民服务的态度，鼓掌。</p>
<p>这是第二次机会接触小片警，每次都是让我失望，绝望，恨之入骨。第一次接触小片警我甚至kill him的心都有了。不一心想着为人民服务，却是一心想着推卸责任，处处刁难市民并从中谋取私利，对市民爱理不理，这就是小片警在我心中的形象，很难改变。越是权利小的小兵，架子越大，这也就决定了永远是个小兵的身份。</p>
<p>如果没有市长热线那这件扰民的事情也就不了了之了，因为投诉110都不管用了，作为市民已经没有可以维权的机构了。还好有市长热线的存在给市民多了一个维权的途径。</p>
<p>上周五打的电话，这个周一给我回复电话问我饭馆在哪一次，周二又打电话问我饭馆在哪，然后周三终于给处理了，下班途中派出所给我电话回复说：“已经处理好了，让小饭馆的音响声音调小了，以后如果再有这种情况可以继续打电话”。等我回家一看，果然音响不见了，世界一下子清净了，zf终于替我办事了。</p>
<p>也许是因为我的事情不是很紧急的原因，整个处理流程过于慢了，等了足足五天的时间才处理好。</p>
<p>当大家的权益受到损害时，请大家多给市长热线打电话维护自己的权益。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/weak_life/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/weak_life/" itemprop="url">
                  脆弱的生命
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-08-05T09:11:24+08:00">
                2013-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/ref/life/weak_life.JPG" alt="Image Title"></p>
<p>得知老家三老爷家的三叔去世了，原本还在看代码的我收到消息之后立刻无法平静了，只好出去走走散散心，回家之后依然感觉莫名的胸闷，玩游戏分散分散精力，游戏过后依然胸闷。意料之中的失眠，中途醒了好几次。总感觉消息不是真实的，总感觉昨晚在梦中，真希望一觉醒来之后什么都没有发生。</p>
<p>三叔42岁，正值壮年，在家附近的号称有一万员工的炼钢厂打工，在整个市也算是很大的企业了。工作中意外丧命。总觉得这样的事情不会发生在我身边，客观事实是发生了。</p>
<p>听家人说，三叔小时候调皮爬到树上掏鸟窝从树上掉下来把一个肩膀都磕到身体里了，大家都觉得肯定好不了，在镇上医院住院打吊瓶打够了自己偷偷跑回学校，后来居然奇迹般的好了，而且还没留下任何痕迹。大家都说三叔命大，谁知三叔小时候躲过了一劫却没有躲过这一劫，这难道就是天命？三叔一生勤俭节约，人忠厚老实，到头来却落得如此下场，谁说上帝是公平的，谁说好人有好报，这都是胡扯。</p>
<p>临近三叔出事的前天，我做了一个很不好的梦，梦的内容我已经记不起来了。回家后听家里人说很多人都做了不好的梦，甚至连平常不怎么做梦的都会被梦惊醒。这绝对不是巧合，很明显已经超出了当前科学的范畴。</p>
<p>记得最后一次跟三叔接触还是在过年的时候，三叔到我家来转转，聊了几句，现在还记忆犹新。再上一次见面就是在去年夏天的一个下午，约着三婶去火车站接三叔家的弟弟和我爸，正巧在三叔家的门口碰到三叔，估计是要去上夜班。</p>
<p>每年过年我们一大家20多人就会团聚在一起，男人一桌，女人一桌，还有我们小孩一桌，其乐融融。最近两年过年三叔是唯一缺席的，由于工作的原因，三叔正巧在过年的时候上夜班。总觉得少了三叔过年的时候是个遗憾，现在看来以后过年要永远遗憾下去了。</p>
<p>企业在追求经济效益的同时，往往会忽略员工的安全。员工伤亡事件屡见不鲜，却很难得到企业的重视。相比人类的伤亡，企业的经济效益显得那么苍白无力。听说钢厂每年总会出些事故，但是事故的赔偿是从所有员工的工资中扣除的，而不是工厂承担，这也是工厂对安全问题不够重视的原因，反正出了事掉血的是员工。</p>
<p>现在村中的人大部分出去在外面打工，农忙时回家忙几天。在此提醒相亲们一定要注意人身安全，没有了安全保障赚再多的钱都白搭。</p>
<p>谨以此文献给为工作而献身的三叔。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/the_earth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/the_earth/" itemprop="url">
                  地球家园
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-07-31T18:46:36+08:00">
                2013-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/ref/life/the_earth.jpg" alt="Image Title"></p>
<p>这段时间，中国大部分的地区都是高温不降，有些地区甚至出现了鸡蛋自然孵化的现象。媒体报道高温热死人的现象也是时有发生，虽说媒体的话不可信，但至少从一个侧面反映了天气的确是较往年同期高出一些，开始渐渐超出人类身体可以承受的温度，开始悄悄的打破往年同期的高温纪录。</p>
<p>最近几年气候变化无常，跟人类的活动绝对脱不了干系。冬天雾霾可以持续一周不散，春天一个月干旱，夏季雨天可以持续一个月不变，秋季如蝉的生命般短暂。在北方已经生活了二十多年的我，这些现象在小时候是极少碰到的，现在却是极其频繁。记得小时候雨天过后时常会在天边挂上一道弯弯的彩虹，记得最后一次见彩虹是在小学一二年纪的时候，自此之后彩虹仅存在了我的脑海里。对于现在的大部分中国人而言，彩虹仅存在于永恒的记忆中和孩子们的画中。</p>
<p>人类近几百年来正在肆无忌惮的向地球母亲索要不该属于人类自己的东西，人类已经占有了迄今为止地球上对人类有价值的且可以占有的所有资源，人类仍然在忘形的开发并破坏着地球上生物赖以生存的家园。</p>
<p>拿中国的三峡大坝举例，从能源的角度考虑的确是有利的。但是从地球生态的角度考虑肯定是有害的。人类的存在时间相对地球是短暂的，地球每一处地形存在就有它存在的理由，已经经过了无数年的实践验证说明地形存在的正确性。可恶的中国ZF，可恨的脑残砖家居然能够利用理论来论证修建三峡的必要及正确性，TMD没学过实践是检验真理的唯一标准。在没有对地球有充足的了解之前不要利用有限的理论来推断并指导实践，因为往往实践之后就再也回不了头，就比如三峡大坝。谁敢说近几年的西南大旱、特大地震跟三峡拖得了干系，可以灾难发生了又有哪个砖家可以站出来声称我可以对这个灾难负责呢？</p>
<p>我从小就一直在担忧一个问题如果再过几十年后几百年后地球上的煤炭、石油等不可再生资源被人类用过了人类该何去何从，我时长为此而忧虑不已。也许这有点杞人忧天，肯定有人会站出来说到那时候随着人类科技的发展早就发现了新能源了，这是谁给的自信？谁这么大胆敢预言人类几十年后一定可以发现新能源？何况不可再生资源中蕴藏着的价值肯定不仅是燃烧带来的能量这点价值，假如几十年后人类已经将石油资源消耗殆尽了，却发现石油中蕴藏着巨大的能量，估计那时候我们只有哭的份了，楚人一炬，可怜焦土。</p>
<p>人类不过是地球上几百万种生物中的一种，如果硬要从广义公平的角度来考虑，人类在生物界占有的太多了，人类已经把该占有的不该占有的全部占为己有，贪婪的本性暴露无遗。很难想象几十年过后我们人类的家园已经成为了什么样子，四处可见的是拔地而起的高楼，柏油路横一条竖一条，无论在地球的哪个角落都能找到人类留下的痕迹。地球该随着人类的发展何去何从，我不敢想象，我能做到的仅仅是节约点力所能及的资源，仅此而已。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/inside_the_c++_object_model_chapter_4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/inside_the_c++_object_model_chapter_4/" itemprop="url">
                  深度探索C++对象模型读书笔记_第四章：函数语意学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-07-25T00:00:00+08:00">
                2013-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="成员函数的各种调用方式"><a href="#成员函数的各种调用方式" class="headerlink" title="成员函数的各种调用方式"></a>成员函数的各种调用方式</h1><h2 id="非静态成员函数的调用方式"><a href="#非静态成员函数的调用方式" class="headerlink" title="非静态成员函数的调用方式"></a>非静态成员函数的调用方式</h2><p>在C++中必须要保证类的非静态成员函数必须和非成员函数的执行效率一致，在编译的过程中，编译期已经将类的非静态成员函数编译为了非成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span>  Test</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> a + b;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> a;		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> size)</span></span></div><div class="line">	&#123;</div><div class="line">	   <span class="keyword">return</span> a + size;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	 <span class="keyword">int</span> a;</div><div class="line">	 <span class="keyword">int</span> b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上述Test类中，编译器会在编译阶段对类中的成员函数做一些转换。下面列出了编译器可能会做出的变换，不同的编译器实现不太一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_TestFv</span><span class="params">(<span class="keyword">const</span> Test * <span class="keyword">const</span> <span class="keyword">this</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a + <span class="keyword">this</span>-&gt;b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_TestFv</span><span class="params">(Test * <span class="keyword">const</span> <span class="keyword">this</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_Testi</span><span class="params">(<span class="keyword">int</span> size, Test * <span class="keyword">const</span> <span class="keyword">this</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a + size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的变换可以总结出如下规律：</p>
<ul>
<li>将成员函数重新改写为一个外部函数，并且对函数的名字进行处理，使在程序中唯一。一种可能的处理办法就是将函数名更改为：函数名<em>类名</em>函数参数。这样即解决了类之间函数名相同的问题，又解决了类之间函数重载的问题。</li>
<li>在函数的参数末尾添加额外的this指针参数。对于const函数添加的this指针为双const类型，对于非const函数则添加的this指针为指向的内容可变的const指针。</li>
<li>在函数内对成员函数的存取采用this指针来实现。</li>
</ul>
<h2 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h2><p>虚函数如果是通过指针类型访问，需要在运行时动态决定指针指向的类型，因此需要访问虚函数表才能够获取正确的虚函数地址。访问虚函数的方式为<code>(*ptr-&gt;vptr[i])(ptr)</code>，其中i代表要调用的虚函数在虚函数表中的索引，最后一个ptr代表要调用虚函数的编译器添加的this指针参数。</p>
<p>关于虚成员函数的更详细问题会在下一个节中进行讨论。</p>
<h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>静态成员函数中没有this指针，可以理解成带类作用域的全局函数，执行效率跟全局函数一致。</p>
<h1 id="虚成员函数-1"><a href="#虚成员函数-1" class="headerlink" title="虚成员函数"></a>虚成员函数</h1><p>这部分内容是本书的核心内容，可以参考陈皓的博客相关文章，已经对C++中的虚成员函数和虚成员变量进行了说明。</p>
<ul>
<li><a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="external">C++ 虚函数表解析</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081328" target="_blank" rel="external">C++ 对象的内存布局(上)</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081385" target="_blank" rel="external">C++ 对象的内存布局(下)</a></li>
</ul>
<h2 id="单一继承下的虚函数"><a href="#单一继承下的虚函数" class="headerlink" title="单一继承下的虚函数"></a>单一继承下的虚函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">virtual</span> ~Point()&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	Point(<span class="keyword">float</span> x=<span class="number">0.0</span>) &#123;_x = x;&#125;</div><div class="line">	<span class="keyword">float</span> _x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Point2d : <span class="keyword">public</span> Point</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Point2d(<span class="keyword">float</span> x=<span class="number">0.0</span>, <span class="keyword">float</span> y=<span class="number">0.0</span>) : Point(x), _y(y) &#123;&#125;</div><div class="line">	~Point2d()&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function">Point2d&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">float</span> _y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Point3d : <span class="keyword">public</span> Point2d</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>, <span class="keyword">float</span> y=<span class="number">0.0</span>, <span class="keyword">float</span> z=<span class="number">0.0</span>) : Point2d(x, y), _z(z) &#123;&#125;</div><div class="line">	~Point3d()&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function">Point3d &amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">float</span> _z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>三个类对应的虚函数表会转化成下图</p>
<p><img src="/ref/c++/c++_object_model/chapter4_1.PNG" alt="Image Title"></p>
<p>通过图中可以看出每个函数在虚函数表中的位置无论在基类还是在子类中位置总是固定的。图中的Point的实例应该是不存在的，因为类中含有纯虚函数mult。</p>
<p>要想调用ptr-&gt;z()就变得非常容易，可以在编译器就可以确定虚函数的调用。虽然ptr所指向的对象在编译器并不能确定，但是编译器可以将其转化成为(*ptr-&gt;vptr[4])(ptr)。因为z()函数总是在虚函数表中的第四个位置，唯一需要在执行期确定的就是ptr所指的对象的实际类型。</p>
<h2 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h2><p>避免重复造轮子，参考上面博文。</p>
<h2 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h2><p>避免重复造轮子，参考上面博文。</p>
<h1 id="函数的效率"><a href="#函数的效率" class="headerlink" title="函数的效率"></a>函数的效率</h1><p>非成员函数、静态成员函数、非静态成员函数都被转换成为了完全相同的形式。<br>inline函数的执行效率最高。<br>虚函数的效率最低。</p>
<h1 id="指向成员函数的指针"><a href="#指向成员函数的指针" class="headerlink" title="指向成员函数的指针"></a>指向成员函数的指针</h1><p>这里学习到一个新的语法，之前没有接触过。即指向类成员函数的指针及使用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Point</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual ~Point() &#123;&#125;</div><div class="line">	float x() &#123;return _x;&#125;</div><div class="line">public:</div><div class="line">	Point(float x=0.0)</div><div class="line">	&#123;</div><div class="line">		_x = x;</div><div class="line">	&#125;</div><div class="line">	float _x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	Point point(1.0);</div><div class="line">	float (Point::*p)();   // 定义指向成员函数的指针</div><div class="line">	p = &amp;Point::x;        // 为指向成员函数的指针赋值</div><div class="line">	cout &lt;&lt; (point.*p)();  // 调用指向类成员函数的指针</div><div class="line">	return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果成员函数的指针并不用于虚函数、多重继承、虚基类等情况，则成员函数的指针效率跟非成员函数指针的效率一致。</p>
<h2 id="指向虚成员函数的指针"><a href="#指向虚成员函数的指针" class="headerlink" title="指向虚成员函数的指针"></a>指向虚成员函数的指针</h2><p>书中对于函数取地址的语法在gcc和vs2008下我试验不成功，语法错误。</p>
<h2 id="多重继承下指向成员函数的指针"><a href="#多重继承下指向成员函数的指针" class="headerlink" title="多重继承下指向成员函数的指针"></a>多重继承下指向成员函数的指针</h2><p>依赖于编译器的实现，用到的情况比较少，没仔细看。</p>
<h2 id="指向成员函数指针的效率"><a href="#指向成员函数指针的效率" class="headerlink" title="指向成员函数指针的效率"></a>指向成员函数指针的效率</h2><p>在引入了虚函数、多重继承、虚基类等情况后，指向成员函数的指针效率有所下降。</p>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联只是一个请求，编译器并不一定会将函数内联的展开。</p>
<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>内联时每一个形参都会被对应的实参取代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> i &lt; j ? i : j;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> minval;</div><div class="line">	<span class="keyword">int</span> val1 = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">int</span> val2 = <span class="number">2048</span>;</div><div class="line">	minval = min(val1, val2);</div><div class="line">	minval = min(<span class="number">1024</span>, <span class="number">2048</span>);</div><div class="line">	minval = min(foo(), bar() + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>minval=min(val1, val2)</code>会被内联展开成<code>minval = val1 &lt; val2 ? val1 : val2</code>。<br><code>minval = min(1024, 2048)</code>会被扩展为<code>minval = 1024</code>。<br><code>minval = min(foo(), bar() + 1)</code>需要引入临时对象，被扩展为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int t1;</div><div class="line">int t2;</div><div class="line">minval = (t1 = foo()) , (t2 = bar() + 1), t1 &lt; t2 ? t1 : t2;</div></pre></td></tr></table></figure></p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> minval = i &lt; j ? i : j;</div><div class="line">	<span class="keyword">return</span> minval;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> minval;</div><div class="line">	<span class="keyword">int</span> val1 = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">int</span> val2 = <span class="number">2048</span>;</div><div class="line">	minval = min(val1, val2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在内联函数中引入局部变量，内联函数在内联的时候局部变量会拥有一个唯一的名称。代码中的<code>minval = min(val1, val2)</code>会被内联为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> _min_lv_minval;</div><div class="line">minval = (_min_lv_minval = val1 &lt; val2 ? val1 : val2), _min_lv_minval;</div></pre></td></tr></table></figure>
<p>内联函数可以代替C语言中的#define宏定义，但是当内联函数调用次数过多，会产生大量的扩展代码，使程序的大小变大。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/inside_the_c++_object_model_chapter_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/inside_the_c++_object_model_chapter_3/" itemprop="url">
                  深度探索C++对象模型读书笔记_第三章：数据语意学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-07-24T00:00:00+08:00">
                2013-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X &#123;&#125;;</div><div class="line">class Y : public virtual X &#123;&#125;;</div><div class="line">class Z : public virtual X &#123;&#125;;</div><div class="line">class A : public Y, public Z &#123;&#125;;</div></pre></td></tr></table></figure>
<p>对于上述代码我在vs2008中的实验结果，X的大小为1，Y和Z的大小为4，A的大小为8。X的大小为1是因为编译器给空类了1字节的空间。Y和Z的大小为4是因为内部包含一个vbptr（指向虚基类的指针）占用了4个字节。A的大小包含了两个vbptr，分别指向虚基类的指针X。利用<code>cl main.cpp /d1reportSingleClassLayoutA</code>命令可以查看对象的内存布局，利用vs2008调试界面查看对象的内存布局往往是不全的，不推荐采用此种方式。下面为A的类布局。<br><img src="/ref/c++/c++_object_model/chapter3_1.PNG" alt="Image Title"></p>
<p>在64位的linux的g++下测试X、Y、Z、A的大小分别为1、8、8、16，这是因为指针的大小为8个字节。</p>
<p>一个类占用的空间比类本身非静态数据成员空间大的原因有如下两点：</p>
<ul>
<li>编译器自动加上额外的数据成员，用来支持某些语言特性，例如virtual特性。</li>
<li>内存边界调整的需要</li>
</ul>
<h1 id="3-1-数据成员的绑定"><a href="#3-1-数据成员的绑定" class="headerlink" title="3.1 数据成员的绑定"></a>3.1 数据成员的绑定</h1><p>味同嚼蜡的章节。</p>
<h1 id="3-2-数据成员的布局"><a href="#3-2-数据成员的布局" class="headerlink" title="3.2 数据成员的布局"></a>3.2 数据成员的布局</h1><p>数据成员在内存中的布局顺序跟数据成员在类中的声明顺序是一致的，而且现在的编译器都不关心数据成员在类中是public、protected还是private的。</p>
<p>为了内存对齐，编译器在变量之间插入了空白字节，不同的编译器内存对齐的原则并不一致。</p>
<p>为了实现虚函数机制，编译器插入了vptr成员变量。</p>
<p>以上这些内容，本章节并没有展开详解。</p>
<h1 id="3-3-数据成员变量的存取"><a href="#3-3-数据成员变量的存取" class="headerlink" title="3.3 数据成员变量的存取"></a>3.3 数据成员变量的存取</h1><p>数据成员包括静态数据成员和非静态数据成员。</p>
<p>静态数据成员变量放在静态存储区，不会造成任何空间或执行时间上的浪费。</p>
<p>对于非静态数据成员，无论成员变量是struct数据成员、类数据成员、单一继承、多重继承情况下执行效率完全一样。执行效率较静态数据成员变量稍低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class  Test</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	 int a;</div><div class="line">	 int b;</div><div class="line">	 int c;</div><div class="line">&#125;;</div><div class="line">Test test;</div></pre></td></tr></table></figure>
<p>在上述例子中要想读取test.c的位置，编译器需要执行类似这样的操作：<code>&amp;test + &amp;Test::c</code>，可以看出对类中变量的存取成本多了一个算数运算。</p>
<p>对于虚拟继承的情况由于需要在运行期才能决定存取操作，需要一些额外的成本，在下文讨论。</p>
<h1 id="3-4-继承与数据成员"><a href="#3-4-继承与数据成员" class="headerlink" title="3.4 继承与数据成员"></a>3.4 继承与数据成员</h1><p>如果类中不包含继承机制，则数据成员的布局和struct中数据成员的布局是一致的。</p>
<p>本节将从单一继承但不包含虚函数、单一继承包含虚函数、多重继承、虚拟继承四个方面讨论数据成员变量。陈浩有几篇博文对此进行了详细的解释，比书上内容要易懂和全面，这几篇文章必看。</p>
<ul>
<li><a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="external">C++ 虚函数表解析</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081328" target="_blank" rel="external">C++ 对象的内存布局(上)</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081385" target="_blank" rel="external">C++ 对象的内存布局(下)</a></li>
</ul>
<h2 id="单一继承且不包含虚函数"><a href="#单一继承且不包含虚函数" class="headerlink" title="单一继承且不包含虚函数"></a>单一继承且不包含虚函数</h2><p>书中举例解释了为什么类继承时类成员之间的填补空白会比单个类时要多，下图的内存布局图中Concrete3继承自Concrete2，Concrete2继承自Concrete1。Concrete3类占用的空间大小为：bit1占用的1个字节+3个字节的空白，bit2占用的1字节+3字节的空白，bit3占用的1字节+3字节空白。如果Concrete3不继承自任何对象，而是包含bit1、bit2、bit3三个变量，占用的空间大小为1+1+1+1=4。</p>
<p><img src="/ref/c++/c++_object_model/chapter3_2.PNG" alt="Image Title"></p>
<p>之所以编译器在继承机制中会作如此处理，是为了在继承机制中对象之间的默认按比特复制操作更方便。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Concrete1 *p1 = <span class="keyword">new</span> Concrete1, *p2 = <span class="keyword">new</span> Concrete2;</div><div class="line">*p2 = *p1;	<span class="comment">// 此时编译器只需要按比特复制就可以了</span></div></pre></td></tr></table></figure>
<h2 id="单一继承包含虚函数"><a href="#单一继承包含虚函数" class="headerlink" title="单一继承包含虚函数"></a>单一继承包含虚函数</h2><p>假设有如下类定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">virtual</span> ~Base()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	~Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> derived_y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>则Derived类的对象模型如下，通过图可以非常清晰的理解单一继承包含虚函数的情况：</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_1.PNG" alt="单一继承包含虚函数的对象模型"></p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base1</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base1()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base1()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base1_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base2</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base2()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base2()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base2\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base2_not_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base2_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	~Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">derived_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> derived_y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>则Vertex3d类的对象模型如下，同样通过图可以非常清晰的理解多重继承的情况：</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_2.PNG" alt="多重继承"></p>
<h2 id="重复继承"><a href="#重复继承" class="headerlink" title="重复继承"></a>重复继承</h2><p>书中并没有涉及到重复继承，重复继承是指某个基类被间接重复继承了多次，属于重复继承和钻石级多重虚拟继承的过渡情况，有必要说明一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base1 : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base1()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base1()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base1\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base1_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base2 : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base2()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base2()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base2\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base2_not_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base2_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	~Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">derived_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> derived_y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过下图的对象模型可以看出，重复继承的类Base在Derived的实例中存在两份，要想直接更改Base类中的base_x变量的值，不能通过<code>derived.base_x = 1</code>直接赋值的方式，需要调用<code>derived.Base1::base_x = 1</code>的方式来更改，更改后的效果仅更改了Base1对象对应的Base类实例中的base_x的值。</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_3.PNG" alt="重复继承"></p>
<h2 id="钻石型多重虚拟继承"><a href="#钻石型多重虚拟继承" class="headerlink" title="钻石型多重虚拟继承"></a>钻石型多重虚拟继承</h2><p>该种方式的继承已经是所有继承中最为复杂的了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;	<span class="comment">// 虚基类最好是不再提供虚函数</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base1 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base1()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base1()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base1\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base1_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base2 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Base2()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Base2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">virtual</span> ~Base2()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Base2\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//virtual void base_virtual_func() &#123;&#125;	// 由于是虚拟继承，不再能重复重载父类的虚函数了</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base2_not_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="keyword">int</span> base2_x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	~Derived()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"~Derived\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">derived_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> derived_y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在下图标出的区域中，我认为Base应该是不存在的，这里只是vs2013为了展示的考虑而添加上的。虚拟继承基类Base位于Derived类对象的除该成员外的最后位置。</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_4.PNG" alt="虚拟继承"></p>
<h1 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h1><p>作者经过试验测试，继承下的类成员读写效率跟读写普通变量效率相差不大，虚拟继承对程序的读写效率有影响。这跟理论上相差不大。</p>
<h1 id="指向数据成员的指针"><a href="#指向数据成员的指针" class="headerlink" title="指向数据成员的指针"></a>指向数据成员的指针</h1><p>小技巧：可以通过<code>&amp;类名::变量名</code>的语法来获取类成员变量在类对象中的位置，即相对于类对象起始地址的偏移量。</p>
<p>书中后面的内容个人感觉没有必要看了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/inside_the_c++_object_model_chapter_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/inside_the_c++_object_model_chapter_2/" itemprop="url">
                  深度探索C++对象模型读书笔记_第二章：构造函数语义学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-07-22T00:00:00+08:00">
                2013-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2-1-默认构造函数的生成"><a href="#2-1-默认构造函数的生成" class="headerlink" title="2.1 默认构造函数的生成"></a>2.1 默认构造函数的生成</h1><p>只有当编译器需要默认构造函数的时候才会合成默认构造函数，并不是类只要没有定义默认构造函数编译器就会合成默认构造函数，而是只有以下四种情况编译器会生成默认构造函数。编译器合成的默认构造函数仅会处理类的基类对象和类中的数据成员对象，对于类中的普通类型的非静态数据成员并不会作任何处理。比如类中一个指针类型的数据成员，编译器合成的默认构造函数不会对该指针作任何处理，该指针就是一个野指针。</p>
<h2 id="带有默认构造函数的类成员对象"><a href="#带有默认构造函数的类成员对象" class="headerlink" title="带有默认构造函数的类成员对象"></a>带有默认构造函数的类成员对象</h2><p>一个类没有定义任何构造函数，该类中包含了一个带有默认构造函数（包括了合成的默认构造函数和定义的默认构造函数）的类成员对象，那么编译器需要为此类合成一个默认构造函数，合成默认构造函数的时机为该构造函数被调用时。合成的默认构造函数默认为内联函数，如果不适合使用内联函数，就合成explicit static的构造函数。</p>
<p>默认构造函数、复制构造函数和赋值操作符的生成都是inline。inline函数有静态链接，不会被当前文件之外的文件看到。如果函数过于复杂不适合生成inline函数，会生成一个explicit non_inline static实体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Dopey</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Dopey();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Sneezy</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Sneezy(<span class="keyword">int</span>);</div><div class="line">	Sneezy();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Bashful</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Bashful();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Snow_White</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Dopey dopey;</div><div class="line">	Sneezy sneezy;</div><div class="line">	Bashful bashful;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> mumble;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	Snow_White snow_white;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述例子中，foo()中需要调用Bashful的构造函数，编译器会为Bar类生成内联的默认构造函数。Bashful类会生成类似于下面的默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> Bar::Bar()</div><div class="line">&#123;</div><div class="line">    dopey.Dopey::Dopey();</div><div class="line">    sneezy.Sneezy::Sneezy();</div><div class="line">    bashful.Bashful::Bashful();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认构造函数的生成原则为：如果类A中包含了一个或一个以上的类成员对象，那么类A的默认构造函数必须调用每一个类成员的默认构造函数。但是不会初始化普通类型的变量，因此在上例中必须手动初始化mumble变量。在编译器合成的默认构造函数中类成员变量的默认构造函数的调用次序为成员变量在类中的声明顺序，该顺序和类成员的构造函数初始化列表顺序是一致的。</p>
<p>如果Snow_White类定义了如下的默认构造函数，则编译器会自动在定义的构造函数中增加调用类成员变量的代码，调用类成员变量相应构造函数的顺序仍然和类成员变量在类中的声明顺序一致。</p>
<p>从中可以看出类成员变量的构造函数的调用要早于类构造函数的调用，这一点是在很多面试题中经常会见到的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义的默认构造函数，包含了类成员变量sneezy的初始化列表</span></div><div class="line">Snow_White::Snow_White() : sneezy(<span class="number">1024</span>)</div><div class="line">&#123;</div><div class="line">	mumble = <span class="number">2048</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译器扩张后的默认构造函数</span></div><div class="line">Snow_White::Snow_White() : sneezy(<span class="number">1024</span>)</div><div class="line">&#123;</div><div class="line">	dopey.Dopey::Dopey();           <span class="comment">// 调用默认构造函数</span></div><div class="line">	sneezy.Sneezy::Sneezy(<span class="number">1024</span>);    <span class="comment">// 自动调用合适的构造函数</span></div><div class="line">	bashful.Bashful::Bashful();</div><div class="line">	mumble = <span class="number">2048</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="带有默认构造函数的基类"><a href="#带有默认构造函数的基类" class="headerlink" title="带有默认构造函数的基类"></a>带有默认构造函数的基类</h2><p>在继承机制中，一个没有构造函数的子类继承自带有默认构造函数的基类，则子类的构造函数会被合成，并且会调用基类的默认构造函数。若子类没有定义默认构造函数，却定义了多个带参数的构造函数，编译器会扩张所有自定义的构造函数，将调用基类默认构造函数的代码添加到子类的构造函数的最前面。</p>
<p>从这里可以看出继承机制中，首先构造基类，后构造子类，这点也是面试题中经常遇到的。</p>
<h2 id="带有虚函数的类"><a href="#带有虚函数的类" class="headerlink" title="带有虚函数的类"></a>带有虚函数的类</h2><p>为了实现虚函数或虚继承机制，编译器需要为每一个类对象设定vptr（指向虚函数表的指针）的初始值，使其指向一个vtbl（虚函数表）的地址。如果类包含构造函数则编译器会生成一些代码来完成此工作；如果类没有任何构造函数，则编译器会在合成的默认构造函数中添加代码来完成此工作。</p>
<h2 id="带有虚基类的类"><a href="#带有虚基类的类" class="headerlink" title="带有虚基类的类"></a>带有虚基类的类</h2><p>需要维护内部指针来实现虚继承。</p>
<h1 id="2-2-复制构造函数的生成"><a href="#2-2-复制构造函数的生成" class="headerlink" title="2.2 复制构造函数的生成"></a>2.2 复制构造函数的生成</h1><p>复制构造函数被调用有三种情况：</p>
<ul>
<li>明确的一个对象的内容作为另外一个对象的初始值。如X xx = x或X xx(x)。</li>
<li>对象作为参数传递给函数时。</li>
<li>类对象作为函数返回值时。</li>
</ul>
<h2 id="合成复制构造函数的情况"><a href="#合成复制构造函数的情况" class="headerlink" title="合成复制构造函数的情况"></a>合成复制构造函数的情况</h2><p>如果一个类没有提供显式的复制构造函数，同默认构造函数一样，只有编译器认为需要合成复制构造函数时，编译器才会合成一个。那么问题来了，什么时候编译器才合成复制构造函数呢？书中给出的答案为当一个类不展现出<em>bitwise copy semantics</em><sup>1</sup>的时候。具体来说有以下四种情况，跟类的默认构造函数的合成基本一致。</p>
<ul>
<li>当类内包含一个类成员变量且类成员变量声明了复制构造函数。</li>
<li>当类继承的基类有复制构造函数（复制构造函数可以是显示声明或合成的）</li>
<li>一个类中包含了一个或多个虚函数</li>
<li>类继承自一个或多个虚基类</li>
</ul>
<p>其中前面两种情况必须将成员变量或基类的复制构造函数的调用插入到合成的复制构造函数中，因此不是按照按比特复制的。第三和第四点分别用下面两小节来说明。</p>
<h2 id="重新设定虚函数表的指针"><a href="#重新设定虚函数表的指针" class="headerlink" title="重新设定虚函数表的指针"></a>重新设定虚函数表的指针</h2><p>当编译器需要在类对象中设定一个指向虚函数表的指针时，该类就不能再使用按位复制的复制构造函数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ZooAnimal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	ZooAnimal();</div><div class="line">	<span class="keyword">virtual</span> ~ZooAnimal();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">animate</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Bear : <span class="keyword">public</span> ZooAnimal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Bear();</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">animate</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// yogi的vptr指向Bear的虚函数表</span></div><div class="line">	Bear yogi;</div><div class="line">	<span class="comment">// franny的vptr指向ZooAnimal的虚函数表</span></div><div class="line">	ZooAnimal franny = yogi;</div><div class="line">	draw(yogi);	<span class="comment">// 调用Bear::draw()</span></div><div class="line">	draw(franny);	<span class="comment">// 调用ZooAnimal::draw()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/ref/c++/c++_object_model/chapter2_1.PNG" alt="Image Title"></p>
<p>合成出来的ZooAnimal的复制构造函数会明确设定对象的vptr指向ZooAnimal的虚函数表，而不是从右值中复制过来的值。</p>
<h2 id="处理virtual-base-class-subobjects"><a href="#处理virtual-base-class-subobjects" class="headerlink" title="处理virtual base class subobjects"></a>处理virtual base class subobjects</h2><p>虚基类的存在需要特别处理，一个类对象如果以另外一个类对象作为初始值，而后者有一个virtual base class subobjects，也会使按比特复制的复制构造函数失效。</p>
<p>每一个编译器都必须让派生的类对象的virtual base class subobjects位置在执行期准备完毕。按比特复制的复制构造函数可能会破坏virtual base class subobjects的位置，因此编译器必须在自己合成出来的复制构造函数中修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ZooAnimal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ZooAnimal();</div><div class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">animate</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Raccoon : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Raccoon();</div><div class="line">    Raccoon(<span class="keyword">int</span> val);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> RedPanda : <span class="keyword">public</span> Raccoon</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    RedPanda();</div><div class="line">    RedPanda(<span class="keyword">int</span> val);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>文章的内容没有完全理解，虚继承机制使用较少，可以暂时不用理解。</p>
<h1 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a>2.3 程序转化语意学</h1><p>本节涉及到了编译器优化的相关细节，由于较容易理解，可以直接看书上内容，对工作帮助不大。包括类对象的初始化优化，函数参数的初始化优化，函数返回值的初始化优化，使用者层面的优化和编译器层面的优化。</p>
<p>如果不是上节指定的四种情况，不需要显示的声明复制构造函数，因为显示的声明的复制构造函数往往效率不如编译器合成的复制构造函数效率高。编译器合成的复制构造函数利用memcpy()或memset()函数来合成，效率最高。</p>
<h1 id="2-4-类成员的初始化列表"><a href="#2-4-类成员的初始化列表" class="headerlink" title="2.4 类成员的初始化列表"></a>2.4 类成员的初始化列表</h1><p>说到类成员的初始化列表必然想起一个经常出现的面试题：成员初始化列表的顺序是按照成员变量在类中声明的顺序。如果成员初始化列表的顺序和成员变量在类中声明的顺序不一致时某些编译器会提示警告。编译器将成员初始化列表的代码插入到构造函数的最开始位置，优先级跟调用类类型的成员变量的默认构造函数是一致的，都是跟类类型成员变量在类中的声明次序相关。</p>
<p>类成员初始化必须使用成员初始化列表的四种方式：</p>
<ul>
<li>初始化一个引用类型的成员变量</li>
<li>初始化一个const的成员变量</li>
<li>调用基类的构造函数，且基类的构造函数采用成员初始化列表的方式</li>
<li>调用类成员的构造函数，且类成员的构造函数采用成员初始化列表的方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span>  Word</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	 Word()</div><div class="line">	 &#123;</div><div class="line">	 	_name = <span class="number">0</span>;</div><div class="line">	 	_cnt = <span class="number">0</span>;</div><div class="line">	 &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	String _name;</div><div class="line">	<span class="keyword">int</span> _cnt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此例子在构造函数中对成员变量进行测试，编译器对构造函数的扩张方式可能会生成如下的伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Word::Word()</div><div class="line">&#123;</div><div class="line">	_name.String::String();</div><div class="line">	String temp = String(<span class="number">0</span>);</div><div class="line">	_name.String::<span class="keyword">operator</span>=(temp);</div><div class="line">	temp.String::~String();</div><div class="line">	_cnt = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数中生成了一个临时性的String对象，这浪费了一部分开销。如果将构造函数该成如下的定义方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Word() : _name(<span class="number">0</span>)</div><div class="line"> &#123;</div><div class="line"> 	_cnt = <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>即将其中的类成员变量更改为成员初始化列表的方式来初始化，编译器会自动将构造函数扩张为如下方式，这样减少了临时对象，提供了程序效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Word::Word()</div><div class="line">&#123;</div><div class="line">	_name.String::String(<span class="number">0</span>);</div><div class="line">	_cnt = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>下面例子是对本章内容的一个简单概况，也是面试题中经常碰到的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()</div><div class="line">    &#123;                                                                                                                                                                           </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    ~A()</div><div class="line">    &#123;   </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"~A\n"</span>);</div><div class="line">    &#125;   </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    B(<span class="keyword">int</span> n)</div><div class="line">    &#123;   </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"B_%d\n"</span>, n); </div><div class="line">    &#125;   </div><div class="line">    ~B()</div><div class="line">    &#123;   </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"~B\n"</span>);</div><div class="line">    &#125;   </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Base\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> ~Base()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"~Base\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Derived() : _m(<span class="number">1</span>), _b(_m)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Derived\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~Derived()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"~Derived\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> _m;</div><div class="line"></div><div class="line">    <span class="comment">// 下面两个类类型的成员遍历的构造函数的调用次序跟在类中的声明次序是相关的</span></div><div class="line">    B _b;   <span class="comment">// 类类型的类成员变量，初始化列表中包含该变量</span></div><div class="line">    A _a;   <span class="comment">// 类类型的类成员变量</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 调用基类的构造函数-&gt;调用子类类类型成员变量的构造函数-&gt;调用子类的构造函数</span></div><div class="line">    Derived derived;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 根据栈的特点，类析构的次序跟构造是相反的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码执行的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Base</div><div class="line">B_1</div><div class="line">A</div><div class="line">Derived</div><div class="line">~Derived</div><div class="line">~A</div><div class="line">~B</div><div class="line">~Base</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章讲述了合成的默认构造函数、合成的复制构造函数和构造函数的成员初始化列表。其中如果类没有定义默认构造函数，只有在文中提到的四种情况下编译器才会合成默认构造函数。合成的复制构造函数在需要的时候编译器就会生成，默认是按对象比特复制的方式实现，有四种情况下编译器是不按照比特复制的方式。</p>
<hr>
<p>[1] bitwise copy semantics书中翻译为“位逐次拷贝”，就是按照内存中的字节进行复制类，感觉翻译不如不翻译好理解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kuring Lyu" />
          <p class="site-author-name" itemprop="name">Kuring Lyu</p>
           
              <p class="site-description motion-element" itemprop="description">一只特立独行的鸟</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">106</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/kuring" title="Github地址" target="_blank">Github地址</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://weibo.com/ilvkai" title="新浪微博" target="_blank">新浪微博</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kuring Lyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>

<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一只特立独行的鸟">
<meta property="og:type" content="website">
<meta property="og:title" content="一只特立独行的鸟">
<meta property="og:url" content="http://kuring.me/page/2/index.html">
<meta property="og:site_name" content="一只特立独行的鸟">
<meta property="og:description" content="一只特立独行的鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一只特立独行的鸟">
<meta name="twitter:description" content="一只特立独行的鸟">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kuring.me/page/2/"/>





  <title> 一只特立独行的鸟 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一只特立独行的鸟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">分享我的学习心得，记录我的学习笔记。趁着年轻多学点东西总是正确的~~~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/question_getaddrinfo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/question_getaddrinfo/" itemprop="url">
                  getaddrinfo函数调用问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-17T00:00:00+08:00">
                2015-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在开发程序的过程中遇到了一个getaddrinfo函数的问题，令我感到非常奇怪。</p>
<p>程序中调用了librdkafka库，当程序选择用-static方式链接所有库时程序会在librdkafka库中某个函数core dump，但是选择动态链接系统库（包括libpthread、libdl、libz、libm、libc等）时程序却能正常运行。</p>
<p>每次程序都回core dump在getaddrinfo函数中，经过搜索发现有人跟我遇到同样的<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=10652" target="_blank" rel="external">问题</a>，但是却没有解决方案。</p>
<p>我这里实验了文中提到了例子，在静态链接的时候确实会报错，动态链接却非常正常，编译选项为<code>g++ -o test_getaddrinfo test_getaddrinfo.cpp -lpthread -Wall -static</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">include &lt;stdio.h&gt;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span> *)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> addrinfo *res = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"x="</span>);</div><div class="line">    <span class="keyword">int</span> ret = getaddrinfo(<span class="string">"localhost"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;res);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d "</span>, ret);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">pthread_t</span> thr;</div><div class="line">        pthread_create(&amp;thr, <span class="literal">NULL</span>, test, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    sleep(<span class="number">5</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现程序在链接的时候会提示如下警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/tmp/cc0WILtn.o: In function `test(void*)&apos;:</div><div class="line">test_getaddrinfo.cpp:(.text+0x49): warning: Using &apos;getaddrinfo&apos; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</div><div class="line">/usr/lib/gcc/x86_64-redhat-linux/4.8.3/../../../../lib64/libpthread.a(libpthread.o): In function `sem_open&apos;:</div><div class="line">(.text+0x685b): warning: the use of `mktemp&apos; is dangerous, better use `mkstemp&apos;</div></pre></td></tr></table></figure>
<p>从网上查看有该警告的人还是非常多的，都是在-static方式链接glibc库时遇到的，但是没有发现很好的解决方案。该问题的原因<br>产生估计是glibc在静态链接时调用libnss库存在问题，因此不提倡静态链接方式。</p>
<p>我看到了两种解决方案：</p>
<p>方案一：用newlib或uClibc来代替glibc来静态链接，这种方案我没有去尝试是否可行。</p>
<p>方案二：用<code>--enable-static-nss</code>重新编译glibc。我试了一下问题仍然存在。</p>
<p>我之所以采用静态链接的方式，是因为开发机器和运行机器的glibc版本不一致造成的。我尝试将libc.so相关文件复制运行机器上，并让程序链接我复制过去的文件，ldd查看可执行文件没有错误，但是当运行程序时会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./xxx: relocation error: /home/kuring/lib/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference</div></pre></td></tr></table></figure>
<p>最终，我放弃了静态链接的方式，采用了动态链接方式来暂时解决了问题。如果你知道解决方案，请告诉我。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=10652" target="_blank" rel="external">getaddrinfo causes segfault if multithreaded and linked statically</a></p>
</li>
<li><p><a href="https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F" target="_blank" rel="external">Even statically linked programs need some shared libraries which is not acceptable for me.</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/2725255/create-statically-linked-binary-that-uses-getaddrinfo" target="_blank" rel="external">Create statically-linked binary that uses getaddrinfo?</a></p>
</li>
<li><p><a href="http://www.akkadia.org/drepper/no_static_linking.html" target="_blank" rel="external">Static Linking Considered Harmful</a></p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/build_lnmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/build_lnmp/" itemprop="url">
                  LNMP开发环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-16T00:00:00+08:00">
                2015-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一篇拿来主义的文章，所有的安装步骤仅为互联网上查找，网络上的教程各种凌乱，这里根据我的实践情况进行了更改，本文仅记录了我的安装过程，由于不同环境可能导致安装步骤不甚相同。</p>
<h1 id="MAC-OS-X-10-10"><a href="#MAC-OS-X-10-10" class="headerlink" title="MAC OS X 10.10"></a>MAC OS X 10.10</h1><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><p>Mac OSX 10.10的系统自带了php、php-fpm，省去了安装的麻烦，可以执行<code>php -v</code>查看php的版本。这里需要简单地修改下php-fpm的配置，否则运行php-fpm会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf</div><div class="line">vim /private/etc/php-fpm.conf</div></pre></td></tr></table></figure>
<p>修改php-fpm.conf文件中的error_log项，默认该项被注释掉，这里需要去注释并且修改为error_log = /usr/local/var/log/php-fpm.log。如果不修改该值，运行php-fpm的时候会提示log文件输出路径不存在的错误。</p>
<p>如果系统中存在多个php-fpm.conf，不知道需要编辑哪一个，可以执行<code>php-fpm -t</code>命令查看php-fpm要读取的配置文件。</p>
<p>通过<code>php-fpm -D</code>来启动php-fpm，可以通过<code>lsof -Pni4 | grep LISTEN | grep php</code>命令来查看php-fpm是否监听在9000端口。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>这里为了简单，直接采用了brew的方式安装。执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install nginx</div></pre></td></tr></table></figure>
<p>nginx的配置文件位于/usr/local/etc/nginx/nginx.conf，默认只能解析html文件，需要配置后才能调用php-fpm解析php文件。下面内容为该修改后的文件全部有效内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">worker_processes  1;</div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line">    sendfile        on;</div><div class="line">    keepalive_timeout  65;</div><div class="line">    server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  localhost;</div><div class="line">        root           /Users/kuring/www;	// 页面存放路径</div><div class="line">        location / &#123;</div><div class="line">            index  index.html index.htm index.php;</div><div class="line">        &#125;</div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line">        location ~ \.php$ &#123;</div><div class="line">            fastcgi_pass   127.0.0.1:9000;</div><div class="line">            fastcgi_index  index.php;</div><div class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</div><div class="line">            include        fastcgi_params;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">include servers/*;</div></pre></td></tr></table></figure>
<p>然后执行<code>nginx</code>命令即可启动，默认监听的端口为8080，在浏览器中输入<code>http://127.0.0.1:8080</code>即可看到nginx的初始界面。nginx要想监听1024以下端口还需要进一步的配置，8080端口既能满足我需求，不再更改。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mysql</div></pre></td></tr></table></figure>
<p>在启动mysql之前可对mysql的配置文件进行更改，我这里需要更改mysql的编码方式，将所有的编码方式都更改为utf8，防止乱码问题的发生。mysql的配置文件为my.cnf，我的位于/usr/local/Cellar/mysql/5.6.25/my.cnf，对文件添加如下内容，有些选项不存在，可手动添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">character-set-server=utf8</div><div class="line"></div><div class="line">[client]</div><div class="line">default-character-set=utf8</div><div class="line"></div><div class="line">[mysqld_safe]</div><div class="line">default-character-set=utf8</div></pre></td></tr></table></figure>
<p>输入<code>mysqld</code>命令即可启动mysql，启动mysql后输入<code>mysql_secure_installation</code>命令对mysql进行配置，可以设置root用户的密码。</p>
<p>通过<code>mysql -uroot -p</code>命令连接到mysql后，输入<code>status</code>命令可查看刚才更改的编码是否生效。</p>
<p>由于不需要长期使用mysql，这里不设置mysql自启动命令。</p>
<h1 id="CentOS6"><a href="#CentOS6" class="headerlink" title="CentOS6"></a>CentOS6</h1><p>我首先采用的方案为完全用普通用户安装，尝试失败后采用root安装依赖库普通用户编译程序的方案。</p>
<h2 id="普通用户安装依赖库"><a href="#普通用户安装依赖库" class="headerlink" title="普通用户安装依赖库"></a>普通用户安装依赖库</h2><p>我首选选择在普通用户kuring下进行安装和运行整个web环境。因此不能使用yum安装方式，必须采用源码安装的方式。通过普通用户安装，最麻烦的地方就在于需要安装很多的依赖库，而依赖的库的安装可能又有需要的库，且库之间存在版本问题。</p>
<p>首先普及几个小知识：</p>
<p>bash查找命令的先后顺序为：</p>
<ol>
<li>alias别名</li>
<li>shell中的关键字，如if等</li>
<li>shell中的函数</li>
<li>shell内置命令，如echo等</li>
<li>$PATH环境变量，PATH中的匹配顺序为从前向后的。</li>
</ol>
<p>程序查找lib库的先后顺序为：</p>
<ol>
<li>编译程序时指定的链接库路径，g++编译器可以通过<code>-Wl,-rpath,路径</code>来指定链接库的路径。</li>
<li>环境变量LD_LIBRARY_PATH指定的搜索路径。</li>
<li>/etc/ld.so.conf指定的路径。</li>
<li>默认的系统动态库搜索路径，如/usr/lib64、/usr/local/lib64等。</li>
</ol>
<p>很多程序采用pkg-config程序来检查库的版本号，pkg-config命令依赖于动态链接库对应的.pc文件，这些.pc文件一般位于系统的/usr/local/lib/pkgconfig目录下。为了能够将安装完成的库通过pkg-config找到对应的.pc文件，需要将.pc文件所在的路径/home/kuring/local/lib/pkg-config设置到环境变量PKG_CONFIG_PATH中。</p>
<p>安装php依赖的libxml2库时提示找不到libtool、autoconf和automake，首先安装libtool。执行<code>./configure --prefix=/home/kuring/local;make; make install</code>将其安装到当前用户的local目录下。</p>
<p>用同样的步骤安装autoconf，执行<code>./configure --prefix=/home/kuring/local;make; make install</code>。</p>
<p>为了能够将安装的程序起作用，需要将/home/kuring/local目录添加到PATH环境变量中，在.bash_profile文件中添加PATH=$PATH:$HOME/local/bin语句，并执行<code>source ~/.bash_profile</code>。</p>
<p>安装之前需要先安装libxml2库，下载地址采用<code>git clone git://git.gnome.org/libxml2</code>的方式下载。在执行<code>sh autogen</code>产生configure配置文件的过程中，发现提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./configure: line 13094: syntax error near unexpected token `LZMA,liblzma,&apos;</div><div class="line">./configure: line 13094: `    PKG_CHECK_MODULES(LZMA,liblzma,&apos;</div></pre></td></tr></table></figure>
<p>经过发现是由于找不到PKG_CHECK_MODULES造成的，正常情况下该函数定义在aclocal.m4文件，而该情况下aclocal.m4文件中并不存在该函数。之所以不存在是由于aclocal命令找不到pkg.m4文件造成的，可以通过<code>aclocal --print</code>命令查看查找的pkg.m4文件的路径。我这里的解决思路为直接从其他机器上复制一个pkg.m4文件过来。</p>
<p>在产生了configure命令后，执行<code>./configure --prefix=/home/kuring/local</code>命令后发现提示找不到Python.h命令的错误。</p>
<p>鉴于遇到了如此之多的错误，本着不浪费生命的原则还是采用yum来安装依赖库吧。</p>
<h2 id="php-1"><a href="#php-1" class="headerlink" title="php"></a>php</h2><p>这里的mysql直接采用了yum命令安装的。</p>
<p>在执行php的<code>./configure</code>命令后提示libxml2找不到错误，直接<code>yum install libxml-devel</code>命令安装libxml-devel即可。然后执行<code>./configure --enable-fpm --prefix=/home/kuring/php5.5 --with-mysqli=/usr/bin/mysql_config;make; make install;</code>。在编译php的时候要加上php-fpm选项来安装php-fpm命令。</p>
<p>安装后配置~/.bash_profile文件的$PATH环境变量的值为：PATH=$HOME/bin:$HOME/php5.5/bin:$HOME/php5.5/sbin:$PATH。</p>
<p>此时即可通过<code>php-fpm -D</code>命令来启动php-fpm命令了。</p>
<p>安装完成后通过phpinfo()函数查看里面有MySQLi的选项，但是实际程序运行的时候居然不支持mysqli的一些力函数，说明mysqli的扩展安装不成功。在/home/kuring/php5.5/include/php/ext/mysqli目录中找到了对应的.h文件，却没有找到mysqli.so的动态链接库文件。大概是由于在编译php时mysql的路径配置有些问题造成的，因为mysql是通过yum安装的，路径比较乱一些。</p>
<p>为了能够产生mysqli.so文件，采用单独编译的方式，在php的源码目录中已经包含了mysqli的源码，进入mysqli源码目录下执行<code>phpize;./configure --prefix=/home/kuring/php5.5/mysqli --with-php-config=/home/kuring/php5.5/bin/php-config --with-mysqli=/usr/bin/mysql_config;make;make install；</code>。将mysqli.so文件安装到了/home/kuring/php5.5/lib/php/extensions/no-debug-non-zts-20121212目录下，不知道为什么目录末尾还要加个这么长的文件夹名，直接将文件复制到上一级目录下。</p>
<p>在/home/kuring/php5.5目录下没有找到php.ini文件，通过<code>php --ini</code>命令查看php的配置文件路径为/home/kuring/php5.5/lib，直接从php的源码文件中复制一个php.ini文件到该目录下。并将php.ini中的增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extension_dir = &quot;/home/kuring/php5.5/lib/php/extensions&quot;</div><div class="line">extension=mysqli.so</div></pre></td></tr></table></figure>
<p>再运行程序，发现mysqli的系列函数已经支持了，好一段折腾。</p>
<h2 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h2><p>执行<code>cp $HOME/php5.5/etc/php-fpm.conf.default $HOME/php5.5/etc/php-fpm.conf</code>来增加配置文件。</p>
<h2 id="nginx-1"><a href="#nginx-1" class="headerlink" title="nginx"></a>nginx</h2><p>首先安装pcre库，该库为正则表达式库。下载后通过</p>
<p>下载源码后执行<code>./configure --prefix /home/kuring/nginx;make;make install;</code>即可安装完成。</p>
<p>修改nginx的配置文件为如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">worker_processes  1;</div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line">    sendfile        on;</div><div class="line">    keepalive_timeout  65;</div><div class="line">    server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  localhost;</div><div class="line">        root           /home/kuring/www;   </div><div class="line">        location / &#123;</div><div class="line">            index  index.html index.htm index.php;</div><div class="line">        &#125;</div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line">        location ~ \.php$ &#123;</div><div class="line">            fastcgi_pass   127.0.0.1:9000;</div><div class="line">            fastcgi_index  index.php;</div><div class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</div><div class="line">            include        fastcgi_params;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">include servers/*;</div></pre></td></tr></table></figure>
<h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><h2 id="nginx-2"><a href="#nginx-2" class="headerlink" title="nginx"></a>nginx</h2><ul>
<li>nginx -s stop：关闭</li>
<li>nginx -t：检测nginx的配置是否正确</li>
</ul>
<h2 id="mysql-1"><a href="#mysql-1" class="headerlink" title="mysql"></a>mysql</h2><ul>
<li>mysqld_safe：启动mysql</li>
<li>mysqladmin shutdown -u root -p：关闭mysql</li>
<li>create user kuring identified by ‘kuring_pass’：mysql创建用户（我尝试过几次，每次创建的用户密码都为空）</li>
<li>drop user kuring：删除一个用户</li>
<li>grant all privileges on <em>.</em> to ‘root’@’%’ identified by ‘root’ with grant option ：允许mysql的root用户通过远程登录</li>
</ul>
<h3 id="创建用户的操作"><a href="#创建用户的操作" class="headerlink" title="创建用户的操作"></a>创建用户的操作</h3><p>使用<code>create user kuring identified by &#39;kuring_pass&#39;</code>命令创建用户kuring。默认创建完成的用户在本机无法登陆，但是远程却可以登陆。 这是因为mysql数据库中的user表中存在一条记录造成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">use mysql;</div><div class="line">select user,host,password from user;</div><div class="line"></div><div class="line">// 在表中存在一条用户名为空的记录</div><div class="line">+---------+-----------+-------------------------------------------+</div><div class="line">| User    | host      | password                                  |</div><div class="line">+---------+-----------+-------------------------------------------+</div><div class="line">| root    | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</div><div class="line">| root    | 127.0.0.1 | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</div><div class="line">| root    | ::1       | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</div><div class="line">|         | localhost |                                           |</div><div class="line">| root    | %         | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</div><div class="line">| report1 | %         | *884CAA4D6FA1C3F7E4849C8DAF1B5B37FCB3EC0B |</div><div class="line">+---------+-----------+-------------------------------------------+</div><div class="line"></div><div class="line">// 将mysql中的为空的记录删除掉，这样就可以通过创建的用户连接了</div></pre></td></tr></table></figure>
<p>在mysql命令行中执行<code>grant all privileges on kuring_db.* to kuring identified by &#39;kuring_pass&#39;</code>命令可以给刚创建的用户对数据库的权限。</p>
<h3 id="修改mysql用户密码"><a href="#修改mysql用户密码" class="headerlink" title="修改mysql用户密码"></a>修改mysql用户密码</h3><p>mysql将用户名和密码存放到了mysql数据库的user表中，在mysql命令行中执行<code>use mysql;update user set password=password(&quot;new password&quot;) where user=&quot;username&quot;;flush privileges;</code>即可更新相应用户的密码。</p>
<h2 id="php-fpm-1"><a href="#php-fpm-1" class="headerlink" title="php-fpm"></a>php-fpm</h2><ul>
<li>php-fpm -D：启动php-fpm，如果需要指定php.ini文件，可以使用-c参数</li>
<li>php-fpm -t：检查php-fpm的配置文件</li>
<li>kill -USR2: 重启php-fpm</li>
<li>kill -INT: 停止php-fpm </li>
</ul>
<h2 id="php-2"><a href="#php-2" class="headerlink" title="php"></a>php</h2><ul>
<li>php –ini：显示php.ini文件路径</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://www.cnblogs.com/hnrainll/archive/2013/01/06/2847069.html" target="_blank" rel="external">运用Autoconf和Automake生成Makefile的学习之路</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/internet_job/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/internet_job/" itemprop="url">
                  期待一份互联网的开发工作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-09T00:00:00+08:00">
                2015-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本人有五年的C++开发经验，工作五年来一直在济南工作，从事的都是行业软件开发，涉及到的行业包括电力、电信和网络安全。做过技术管理，带过20人以下的团队。</p>
<p>现在个人在技术发展上遇到了瓶颈，而自己对技术非常感兴趣，想往技术的深层次方向发展。</p>
<p>本人一直期望能够去一家互联网公司工作，可惜的是济南没有互联网公司。现在本人期望能够去北京的一家互联网公司的靠谱团队中从事Linux下的C++开发，踏踏实实做技术开发。</p>
<p>下面是我的个人简历，附件中提供了PDF格式的简历，如果有符合我的职位，请帮忙推荐，可直接发邮件给我或在本文下方留言，谢谢。</p>
<hr>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>吕凯 / 男 / 1987年</li>
<li>手机：18678879533</li>
<li>Email：kuring.public@gmail.com</li>
<li>学位：硕士 / 山东大学 / 软件工程</li>
<li>工作年限：5年</li>
<li>技术博客：<a href="http://kuring.me（坚持写博客）" target="_blank" rel="external">http://kuring.me（坚持写博客）</a></li>
<li>GitHub：<a href="https://github.com/kuring" target="_blank" rel="external">https://github.com/kuring</a></li>
<li>期望职位：C++高级程序员（Linux方向）</li>
<li>期望薪资：税前月薪25k</li>
<li>期望城市：北京</li>
<li>简短介绍：五年C++开发经验，带领过20人以下团队</li>
</ul>
<hr>
<h1 id="主要特长"><a href="#主要特长" class="headerlink" title="主要特长"></a>主要特长</h1><p>本人工作中以C++为主，工作中或业余时间也做过其他技术的开发，并都有一定的项目经验。带过两年团队，具备一定的技术团队管理经验。</p>
<ul>
<li>五年C++编程经验，Windows和Linux下的开发均做过，擅长做Linux下的C++后台程序开发；熟练使用Qt类库，可用C++开发跨平台的程序。</li>
<li>熟练使用常用的Linux命令，编写Shell脚本。</li>
<li>掌握Python语言，可以编写脚本。</li>
<li>掌握Android开发，做过几个项目。</li>
<li>掌握Java编程，掌握J2EE平台开发技术，掌握Struts、Hibernate、Spring等技术。</li>
<li>掌握PHP，有基于PHP的商业网站开发经验。</li>
<li>掌握Web前端界面的开发技术，HTML、CSS、JavaScript等。</li>
<li>掌握MySQL等关系型数据库及SQL语句。</li>
<li>熟悉大数据处理的开源软件，如Hadoop、HBase、Lucene、Solr、MongoDB、LevelDB等。</li>
<li>了解Linux内核。</li>
</ul>
<hr>
<h1 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h1><ul>
<li>2012.09-2015.01 / 山东大学 / 在职研究生 / 软件工程</li>
<li>2006.09-2010.7 / 济南大学 / 本科 / 计算机科学与技术</li>
</ul>
<hr>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="济南诚方网络科技有限公司-（-2013年8月-2015年6月-）"><a href="#济南诚方网络科技有限公司-（-2013年8月-2015年6月-）" class="headerlink" title="济南诚方网络科技有限公司 （ 2013年8月 ~ 2015年6月 ）"></a>济南诚方网络科技有限公司 （ 2013年8月 ~ 2015年6月 ）</h2><h3 id="VPN破解项目"><a href="#VPN破解项目" class="headerlink" title="VPN破解项目"></a>VPN破解项目</h3><ul>
<li>编程语言：C++</li>
<li>开发工具：Linux环境下的Vim、Eclipse CDT等</li>
<li>项目描述：对PPTP协议进行破解密码和解密还原数据。</li>
<li>项目职责：带领团队完成，设计项目的架构，分配项目的难点问题研究，解决项目中的难题，编写程序的主框架，编写项目文档。在开发的过程中参照了很多的开源软件及rfc文档。</li>
</ul>
<h3 id="WIFI监控平台项目"><a href="#WIFI监控平台项目" class="headerlink" title="WIFI监控平台项目"></a>WIFI监控平台项目</h3><ul>
<li>编程语言：C++</li>
<li>开发工具：Linux环境下的Vim、Qt Creator、Eclipse CDT等</li>
<li>项目描述：实现WIFI的密码在线破解，在连接WIFI后通过arp欺骗的方式抓取数据包，并可对抓取的数据包进行数据的协议还原和cookie欺骗。</li>
<li>项目职责：带领团队完成，负责设计项目的架构，解决项目中的难题。在开发过程中阅读了很多开源软件，解决了很多的技术难题。</li>
</ul>
<h3 id="某大型数据分析分布式系统"><a href="#某大型数据分析分布式系统" class="headerlink" title="某大型数据分析分布式系统"></a>某大型数据分析分布式系统</h3><ul>
<li>编程语言：C++</li>
<li>开发工具：Linux环境下的Vim、Eclipse CDT等和Windows平台的Visual Studio</li>
<li>项目描述：大型分布式系统，能够实现对互联网数据的解析还原和查询，并能够对互联网的异常数据进行报警。</li>
<li>项目职责：新功能开发和已有功能完善。</li>
</ul>
<h2 id="北京市开拓天际信息技术有限公司-（-2012年3月-2013年8月-）"><a href="#北京市开拓天际信息技术有限公司-（-2012年3月-2013年8月-）" class="headerlink" title="北京市开拓天际信息技术有限公司 （ 2012年3月 ~ 2013年8月 ）"></a>北京市开拓天际信息技术有限公司 （ 2012年3月 ~ 2013年8月 ）</h2><h3 id="超声波通信软件研发"><a href="#超声波通信软件研发" class="headerlink" title="超声波通信软件研发"></a>超声波通信软件研发</h3><ul>
<li>编程语言：C++、Java</li>
<li>开发工具：Visual Studio、Eclipse、Qt类库</li>
<li>项目描述：两个设备之间可以通过声卡利用超声波通信，支持Windows平台和Android平台，其中Windows平台利用C++语言开发，Android平台通过JNI调用C++库。</li>
<li>项目职责：尝试多种通信解决方案，负责其中的编码工作。</li>
</ul>
<h3 id="Android短信管家类项目"><a href="#Android短信管家类项目" class="headerlink" title="Android短信管家类项目"></a>Android短信管家类项目</h3><ul>
<li>编程语言：Java</li>
<li>开发工具：Eclipse</li>
<li>项目描述：为Android平台开发的一款可以对系统短信进行自动分类、垃圾短信过滤等管理功能的软件，全部工作由我一人完成。</li>
</ul>
<h3 id="海量数据分布式存储方案研究"><a href="#海量数据分布式存储方案研究" class="headerlink" title="海量数据分布式存储方案研究"></a>海量数据分布式存储方案研究</h3><ul>
<li>编程语言：Java、C++</li>
<li>项目描述：电信行业信令的海量数据的分布式存储方案研究，涉及技术包括：Hadoop、HBase、Solr、MongoDB等开源软件。</li>
</ul>
<h3 id="智慧商家项目"><a href="#智慧商家项目" class="headerlink" title="智慧商家项目"></a>智慧商家项目</h3><ul>
<li>编程语言：PHP、C++、Shell、Python、HTML、JavaScript、CSS</li>
<li>项目描述：针对商铺定制的无线路由器，为用户提供了多种登录方式，支持商圈功能。</li>
<li>项目职责：负责路由器的鉴权中心开发，最初基于PHP +Mysql，后来考虑到性能更改为Apache Module和C++服务端方式开发。</li>
</ul>
<h3 id="电信行业精准营销系统"><a href="#电信行业精准营销系统" class="headerlink" title="电信行业精准营销系统"></a>电信行业精准营销系统</h3><ul>
<li>编程语言：Shell、Python为主</li>
<li>项目描述：采用数据挖掘等技术对电信行业的手机信令进行分析，为电信运营商提供商业支持。</li>
</ul>
<h2 id="积成电子股份有限公司-（-2010年7月-2012年3月-）"><a href="#积成电子股份有限公司-（-2010年7月-2012年3月-）" class="headerlink" title="积成电子股份有限公司 （ 2010年7月 ~ 2012年3月 ）"></a>积成电子股份有限公司 （ 2010年7月 ~ 2012年3月 ）</h2><h3 id="iES-DMS1000E配网自动化系统项目"><a href="#iES-DMS1000E配网自动化系统项目" class="headerlink" title="iES-DMS1000E配网自动化系统项目"></a>iES-DMS1000E配网自动化系统项目</h3><ul>
<li>操作系统：跨平台（Windows、Linux、Solaris、AIX、HP-UNIX等均可运行）</li>
<li>编程语言：C++、Qt</li>
<li>开发工具：Visual Studio、Gcc、Qt Designer、Oracle 10g</li>
<li>项目描述：在国内配网自动化领域名列前茅的系统，系统主要实现配电的管理和监控功能，运行于电力系统安全一区，包含了软总线、前置服务、实时服务、历史数据服务、事项服务、人机界面、绘图工具、报表模块、拓扑和仿真模块、WEB界面等多个模块。</li>
<li>项目职责： 负责系统bug修复和新功能开发。</li>
</ul>
<h2 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h2><h3 id="中国医院管理咨询网"><a href="#中国医院管理咨询网" class="headerlink" title="中国医院管理咨询网"></a>中国医院管理咨询网</h3><ul>
<li>编程语言：PHP、JavaScript</li>
<li>开发环境：Mysql、Apache、dedecms、CSS</li>
<li>项目描述： 该项目为在工作之余所做，自己负责与客户的沟通、代码的编写。系统采用织梦内容管理系统作为开发框架，包含会员登录、企业风采、管理培训、下载功能等模块。页面布局采用CSS，可以完全兼容常用浏览器。</li>
</ul>
<h3 id="X放映室网站开发"><a href="#X放映室网站开发" class="headerlink" title="X放映室网站开发"></a>X放映室网站开发</h3><ul>
<li>编程语言：Java、JavaScript、Jsp</li>
<li>开发环境：Mysql、Tomcat、Struts1.x、Spring2.5、JPA、CSS、AJAX</li>
<li>项目描述：J2EE的练手项目，系统主要模仿当时迅雷看看，主要分为电影模块、电视剧模块、动漫模块、综艺模块、下载模块、广告模块等。</li>
</ul>
<hr>
<p><a href="http://pan.baidu.com/s/1i3KRMYD" target="_blank" rel="external">PDF简历下载</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/company_question/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/company_question/" itemprop="url">
                  公司问题及经验总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-01T00:00:00+08:00">
                2015-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我在软件行业工作已经有五个年头了，在现在这家公司已经有两个年头了。虽然身为公司的研发部经理可以参与公司的一些决定，但是没有绝对的话语权，对于公司的很多决定我深知是错误的，虽然后来也证明是错误的，但是我仍然无能为力。这里总结一下在公司中遇到的问题。</p>
<p>宁可招聘一个技术水平高的也不愿招聘三个技术水平低的。在工作中能够非常有力的证明这一点，三个刚工作的技术人员，尤其对于C++这样门槛稍微高一些，需要工作经验来弥补C++中坑的语言，三个C++技术人员远没有一个高水平的工作效率高，因为三个菜鸟需要将大牛踩过的坑全部踩一遍，踩过多少坑就代表走了多少弯路。</p>
<p>兴趣是最大的老师。我带过不少人，很多都是新人，我给他们制定了学习计划，期望他们能够在业余时间多学习，但实际上哪有几个人能够充分利用业余时间的。我就非常怀疑他们对技术的兴趣问题，如果他们对技术不感兴趣那为什么要加入该行业，为没有兴趣的工作而工作就是自己对自己耍流氓。如果他们对技术感兴趣，那只能说明他们业余时间中有更大的诱惑。</p>
<p>在招聘中不要过于在意金钱，便宜无好货在招聘行业中仍然非常适用。在招聘中千万不要吝惜给员工的那点钱，因为一千块钱而错失一个好的员工是非常不值得的。</p>
<p>盈利模式决定了公司对产品的态度。我所在的软件行业属于传统的软件行业，传统软件行业的盈利模式为销售，由于软件具有可复制性的特点，因此只要一套产品卖的越多就赚的越多。对于传统软件行业的产品使用者很多情况下就是几个人，至少跟互联网产品的用户数量不在一个量级。使用的人数决定了传统软件行业的用户体验可以做的很烂，技术水平可以不用那么高，只要能用就行，慢点无所谓，只要能卖出去就行了。身为一个技术人员，一个对技术有追求的技术人员，这令我非常反感，我做技术我不能对技术无所谓，我讨厌听到无所谓这样的字眼。</p>
<p>一定要明确公司的定位，明白什么时候应该干什么，什么应该干，野心太大也是问题。公司处于成长阶段提出了今年营业额比去年增长10倍的目标，我听到之后就是嗤之以鼻，这压根就是不可能的任务，而事实证明这也根本不可能完成，实际上当年营业额仅比去年增长了一倍。</p>
<p>一家公司一定要有自己的明确产品线，要抵住外界的诱惑。公司的产品线本来是非常明确的，后来由于客户需求和各种方面的原因，开始考虑疯狂扩展产品，这就造成了本来人手就紧蹙的情况下，没有时间去改善现有的系统，不得不去研发新的产品。自己没有的产品甚至跟客户合作或者完全购买别人的产品，导致公司很多人都在考虑跟其他公司合作的事宜。结果可想而知，新产品的销售并不理想，旧有的产品升级维护的也开始变慢。ps：我是非常讨厌在技术上跟其他公司之间考虑合作的问题，因为这从本质上讲并没有产生任何的社会价值，技术上必然涉及到接口的问题，只要是接口必然会有很多细节问题，这些往往会出现技术人员扯皮的问题，一个问题你可以解决他也可以解决，但是谁都不愿意解决，你说烦不烦。</p>
<p>技术人员后来要么转行要么做管理了。在济南技术人员就这两种出路吧，没见过多少大龄的程序员，很多情况下写着写着程序突然发现自己转为公司的中层了，比如我，并逐渐参与公司的事务。很多对程序不感兴趣的，可能就直接换个行业或者转行做销售了。</p>
<p>有些人再怎么培养也成不了高手。在工作我发现，有些人即使有了几年的工作经验，对公司的产品也非常了解，但是在解决问题的时候总是找不到点子上，占了一大堆资源，最后解决起问题来即慢又绕弯路，还留下一堆bug。对于这部分人，我想说也许这个行业不适合你。</p>
<p>领导千万不可三天两头一个想法，这在员工看来就是一个不靠谱的领导。谁都不愿意追随一个拿着自己当猴耍的领导，一会一个想法只能说明领导不够成熟，不适合做领导。跟随杰出的人，为杰出的人工作。</p>
<p>搞公司最好不要搞施工太久的。公司很多做工程的都在为现场的情况忙碌，一个点架设完毕后往往还需要耗费大量的时间来维护，维护对于公司而言牵涉到精力太大，尽量避免需要整天跟客户打交道和整天维护的业务。</p>
<p>专科生是很难撑起一家科技企业。虽然我不完全认同学历就能决定能力，但学历跟能力之间是成正比关系的。我的朋友中有专科生在工作几年后可以做专业的视频教程，并且业余时间写过几部玄幻小说。由于学习经历的不同这就造就了科班出身的程度不同，自然能力之间是有差异的。虽然中国的大学教育跟工作很脱节，但是在工作中还是能够跟大学教育挂起钩来的。学历跟素质之间也是成正比关系的，这里的素质体现在工作中就包括了工作中的责任心，工作态度等方面，这里就不展开了，要展开的话我可以举出非常多活生生的例子。因此，我非常不提倡在公司招聘中招聘专科生。我发现在很多情况下，很多专科人员是连普通话都不会的，操着各种方言或各种被普通话的方言。基本上能不能说普通话也是一个断定人素质的标准，扩展到其他行业同样适用。</p>
<p>也许本文的观点有些偏激，没错我就是一个偏激的IT工程师，就酱。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/cpp11_right_reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/cpp11_right_reference/" itemprop="url">
                  C++11中的右值引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-18T00:00:00+08:00">
                2015-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在C++98中有左值和右值的概念，不过这两个概念对于很多程序员并不关心，因为不知道这两个概念照样可以写出好程序。在C++11中对右值的概念进行了增强，我个人理解这部分内容是C++11引入的特性中最难以理解的了。该特性的引入至少可以解决C++98中的移动语义和完美转发问题，若你还不清楚这两个问题是什么，请向下看。</p>
<p>温馨提示，由于内容比较难懂，请仔细看。C++已经够复杂了，C++11中引入的新特性令C++更加复杂了。在学习本文的时候一定要理解清楚左值、右值、左值引用和右值引用。</p>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><p>首先看一个C++98中的关于函数返回类对象的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyString &#123;</div><div class="line"><span class="keyword">public</span>: </div><div class="line">    MyString() &#123; </div><div class="line">        _data = <span class="literal">nullptr</span>; </div><div class="line">        _len = <span class="number">0</span>; </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Constructor is called!\n"</span>);</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* p) &#123; </div><div class="line">        _len = <span class="built_in">strlen</span> (p); </div><div class="line">        _init_data(p); </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor is called! this-&gt;_data: "</span> &lt;&lt; (<span class="keyword">long</span>)_data &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    MyString(<span class="keyword">const</span> MyString&amp; str) &#123; </div><div class="line">        _len = str._len; </div><div class="line">        _init_data(str._data); </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructor is called! src: "</span> &lt;&lt; (<span class="keyword">long</span>)str._data &lt;&lt; <span class="string">" dst: "</span> &lt;&lt; (<span class="keyword">long</span>)_data &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ~MyString() &#123; </div><div class="line">        <span class="keyword">if</span> (_data)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"DeConstructor is called! this-&gt;_data: "</span> &lt;&lt; (<span class="keyword">long</span>)_data &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">            <span class="built_in">free</span>(_data);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DeConstructor is called!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123; </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </div><div class="line">            _len = str._len; </div><div class="line">            _init_data(str._data); </div><div class="line">        &#125; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Assignment is called! src: "</span> &lt;&lt; (<span class="keyword">long</span>)str._data &lt;&lt; <span class="string">" dst"</span> &lt;&lt; (<span class="keyword">long</span>)_data &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span> *() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> _data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line">    <span class="keyword">char</span> *_data; </div><div class="line">    <span class="keyword">size_t</span>   _len; </div><div class="line"></div><div class="line">    <span class="keyword">void</span> _init_data(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123; </div><div class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; </div><div class="line">        <span class="built_in">memcpy</span>(_data, s, _len); </div><div class="line">        _data[_len] = <span class="string">'\0'</span>; </div><div class="line">    &#125; </div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="function">MyString <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">MyString <span class="title">middle</span><span class="params">(<span class="string">"123"</span>)</span></span>;</div><div class="line">    <span class="keyword">return</span> middle;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">    MyString a = foo(); </div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该例子在编译器没有进行优化的情况下会输出以下内容，我在输出的内容中做了注释处理，如果连这个例子的输出都看不懂，建议再看一下C++的语法了。我这里使用的编译器命令为<code>g++ test.cpp -o main -g -fno-elide-constructors</code>，之所以要加上<code>-fno-elide-constructors</code>选项时因为g++编译器默认情况下会对函数返回类对象的情况作<em>返回值优化</em>处理，这不是我们讨论的重点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// middle对象的构造函数</span></div><div class="line">Copy Constructor is called! src: <span class="number">29483024</span> dst: <span class="number">29483056</span> <span class="comment">// 临时对象的构造，通过middle对象调用复制构造函数</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// middle对象的析构</span></div><div class="line">Copy Constructor is called! src: <span class="number">29483056</span> dst: <span class="number">29483024</span>	<span class="comment">// a对象构造，通过临时对象调用复制构造函数</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483056</span> <span class="comment">// 临时对象析构</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// a对象析构</span></div></pre></td></tr></table></figure>
<p>在上述例子中，临时对象的构造、复制和析构操作所带来的效率影响一直是C++中为人诟病的问题，临时对象的构造和析构操作均对堆上的内存进行操作，而如果_data的内存过大，势必会非常影响效率。从程序员的角度而言，该临时对象是透明的。而这一问题正是C++11中需要解决的问题。</p>
<p>在C++11中解决该问题的思路为，引入了移动构造函数，移动构造函数的定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MyString(MyString &amp;&amp;str) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Constructor is called! src: "</span> &lt;&lt; (<span class="keyword">long</span>)str._data &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    _len = str._len;</div><div class="line">    _data = str._data;</div><div class="line">    str._data = <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移动构造函数中我们窃取了str对象已经申请的内存，将其拿为己用，并将str申请的内存给赋值为nullptr。移动构造函数和复制构造函数的不同之处在于移动构造函数的参数使用<em>&amp;&amp;</em>，这就是下文要讲解的右值引用符号。参数不再是const，因为在移动构造函数需要修改右值str的内容。</p>
<p>移动构造函数的调用时机为用来构造临时变量和用临时变量来构造对象的时候移动语义会被调用。可以通过下面的输出结果看到，我们所使用的编译参数为<code>g++ test.cpp -o main -g -fno-elide-constructors --std=c++11</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">22872080</span> <span class="comment">// middle对象构造</span></div><div class="line">Move Constructor is called! src: <span class="number">22872080</span> <span class="comment">// 临时对象通过移动构造函数构造，将middle申请的内存窃取</span></div><div class="line">DeConstructor is called! <span class="comment">// middle对象析构</span></div><div class="line">Move Constructor is called! src: <span class="number">22872080</span> <span class="comment">// 对象a通过移动构造函数构造，将临时对象的内存窃取</span></div><div class="line">DeConstructor is called! <span class="comment">// 临时对象析构</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">22872080</span> <span class="comment">// 对象a析构</span></div></pre></td></tr></table></figure>
<p>通过输出结果可以看出，整个过程中仅申请了一块内存，这也正好符合我们的要求了。</p>
<h1 id="C-98中的左值和右值"><a href="#C-98中的左值和右值" class="headerlink" title="C++98中的左值和右值"></a>C++98中的左值和右值</h1><p>我们先来看下C++98中的左值和右值的概念。左值和右值最直观的理解就是一条语句等号左边的为左值，等号右边的为右值，而事实上该种理解是错误的。左值：可以取地址，有名字的值，是一个指向某内存空间的表达式，可以使用&amp;操作符获取内存地址。右值：不能取地址，即非左值的都是右值，没有名字的值，是一个临时值，表达式结束后右值就没有意义了。我想通过下面的例子，读者可以清楚的理解左值和右值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lvalues:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line">i = <span class="number">43</span>; <span class="comment">// i是左值</span></div><div class="line"><span class="keyword">int</span>* p = &amp;i; <span class="comment">// i是左值</span></div><div class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">foo() = <span class="number">42</span>; <span class="comment">// foo()返回引用类型是左值</span></div><div class="line"><span class="keyword">int</span>* p1 = &amp;foo(); <span class="comment">// foo()可以取地址是左值</span></div><div class="line"></div><div class="line"><span class="comment">// rvalues:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">foobar</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">j = foobar(); <span class="comment">// foobar()是右值</span></div><div class="line"><span class="keyword">int</span>* p2 = &amp;foobar(); <span class="comment">// 编译错误，foobar()是右值不能取地址</span></div><div class="line">j = <span class="number">42</span>; <span class="comment">// 42是右值</span></div></pre></td></tr></table></figure>
<h1 id="C-11右值引用和移动语义"><a href="#C-11右值引用和移动语义" class="headerlink" title="C++11右值引用和移动语义"></a>C++11右值引用和移动语义</h1><p>在C++98中有引用的概念，对于<code>const int &amp;m = 1</code>，其中m为引用类型，可以对其取地址，故为左值。在C++11中，引入了右值引用的概念，使用<em>&amp;&amp;</em>来表示。在引入了右值引用后，在函数重载时可以根据是左值引用还是右值引用来区分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(MyString &amp;str)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"left reference"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(MyString &amp;&amp;str)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"right reference"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="function">MyString <span class="title">a</span><span class="params">(<span class="string">"456"</span>)</span></span>; </div><div class="line">    fun(a); <span class="comment">// 左值引用，调用void fun(MyString &amp;str)</span></div><div class="line">    fun(foo()); <span class="comment">// 右值引用，调用void fun(MyString &amp;&amp;str)</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在绝大多数情况下，这种通过左值引用和右值引用重载函数的方式仅会在类的构造函数和赋值操作符中出现，被例子仅是为了方便采用函数的形式，该种形式的函数用到的比较少。上述代码中所使用的将资源从一个对象到另外一个对象之间的转移就是移动语义。这里提到的资源是指类中的在堆上申请的内存、文件描述符等资源。</p>
<p>前面已经介绍过了移动构造函数的具体形式和使用情况，这里对移动赋值操作符的定义再说明一下，并将main函数的内容也一起更改，将得到如下输出结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) &#123; </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Operator= is called! src: "</span> &lt;&lt; (<span class="keyword">long</span>)str._data &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </div><div class="line">        <span class="keyword">if</span> (_data != <span class="literal">nullptr</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">free</span>(_data);</div><div class="line">        &#125;</div><div class="line">        _len = str._len;</div><div class="line">        _data = str._data;</div><div class="line">        str._len = <span class="number">0</span>;</div><div class="line">        str._data = <span class="literal">nullptr</span>;</div><div class="line">    &#125;     </div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">    MyString b;</div><div class="line">    b = foo();</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出结果，整个过程仅申请了一个内存地址</span></div><div class="line">Constructor is called! <span class="comment">// 对象b构造函数调用</span></div><div class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">14835728</span> <span class="comment">// middle对象构造</span></div><div class="line">Move Constructor is called! src: <span class="number">14835728</span> <span class="comment">// 临时对象通过移动构造函数由middle对象构造</span></div><div class="line">DeConstructor is called! <span class="comment">// middle对象析构</span></div><div class="line">Move Operator= is called! src: <span class="number">14835728</span> <span class="comment">// 对象b通过移动赋值操作符由临时对象赋值</span></div><div class="line">DeConstructor is called! <span class="comment">// 临时对象析构</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">14835728</span> <span class="comment">// 对象b析构函数调用</span></div></pre></td></tr></table></figure>
<p>在C++中对一个变量可以通过const来修饰，而const和引用是对变量约束的两种方式，为并行存在，相互独立。因此，就可以划分为了const左值引用、非const左值引用、const右值引用和非const右值引用四种类型。其中左值引用的绑定规则和C++98中是一致的。</p>
<p>非const左值引用只能绑定到非const左值，不能绑定到const右值、非const右值和const左值。这一点可以通过const关键字的语义来判断。</p>
<p>const左值引用可以绑定到任何类型，包括const左值、非const左值、const右值和非const右值，属于万能引用类型。其中绑定const右值的规则比较少见，但是语法上是可行的，比如<code>const int &amp;a = 1</code>，只是我们一般都会直接使用<code>int &amp;a = 1</code>了。</p>
<p>非const右值引用不能绑定到任何左值和const右值，只能绑定非const右值。</p>
<p>const右值引用类型仅是为了语法的完整性而设计的， 比如可以使用<code>const MyString &amp;&amp;right_ref = foo()</code>，但是右值引用类型的引入主要是为了移动语义，而移动语义需要右值引用是可以被修改的，因此const右值引用类型没有实际意义。</p>
<p>我们通过表格的形式对上文中提到的四种引用类型可以绑定的类型进行总结。</p>
<table>
<thead>
<tr>
<th>引用类型/是否绑定</th>
<th>非const左值</th>
<th>const左值</th>
<th>非const右值</th>
<th>const右值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>非const左值引用     | 是 | 否 | 否 | 否 |无 |<br>const左值引用       | 是 | 是 | 是 | 是 | 全能绑定类型，绑定到const右值的情况比较少见 |<br>非const右值引用     | 否 | 否 | 是 | 否 | C++11中引入的特性，用于移动语义和完美转发 |<br>const值引用         | 是 | 否 | 否 | 否 | 没有实际意义，为了语法完整性而存在 |</p>
<p>下面针对上述例子，我们看一下foo函数绑定参数的情况。</p>
<p>如果只实现了<code>void foo(MyString &amp;str)</code>，而没有实现<code>void fun(MyString &amp;&amp;str)</code>，则和之前一样foo函数的实参只能是非const左值。</p>
<p>如果只实现了<code>void foo(const MyString &amp;str)</code>，而没有实现<code>void fun(MyString &amp;&amp;str)</code>，则和之前一样foo函数的参数即可以是左值又可以是右值，因为const左值引用是万能绑定类型。</p>
<p>如果只实现了<code>void foo(MyString &amp;&amp;str)</code>，而没有实现<code>void fun(MyString &amp;str)</code>，则foo函数的参数只能是非const右值。</p>
<h1 id="强制移动语义std-move"><a href="#强制移动语义std-move" class="headerlink" title="强制移动语义std::move()"></a>强制移动语义std::move()</h1><p>前文中我们通过右值引用给类增加移动构造函数和移动赋值操作符已经解决了函数返回类对象效率低下的问题。那么还有什么问题没有解决呢？</p>
<p>在C++98中的swap函数的实现形式如下，在该函数中我们可以看到整个函数中的变量a、b、c均为左值，无法直接使用前面移动语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">( T&amp; a, T&amp; b )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">T <span class="title">c</span><span class="params">(a)</span></span>; </div><div class="line">    a=b;</div><div class="line">    b=c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果该函数中能够使用移动语义是非常合适的，仅是为了交换两个变量，却要反复申请和释放资源。按照前面的知识变量c不可能为非const右值引用，因为变量a为非const左值，非const右值引用不能绑定到任何左值。</p>
<p>在C++11的标准库中引入了std::move()函数来解决该问题，该函数的作用为将其参数转换为右值。在C++11中的swap函数就可以更改为了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt; </div><div class="line">void swap (T&amp; a, T&amp; b)</div><div class="line">&#123;</div><div class="line">    T c(std::move(a)); </div><div class="line">    a=std::move(b); </div><div class="line">    b=std::move(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用了move语义以后,swap函数的效率会大大提升，我们更改main函数后测试如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="comment">// move函数</span></div><div class="line">    <span class="function">MyString <span class="title">d</span><span class="params">(<span class="string">"123"</span>)</span></span>;</div><div class="line">    <span class="function">MyString <span class="title">e</span><span class="params">(<span class="string">"456"</span>)</span></span>;</div><div class="line">    swap(d, e);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出结果，通过输出结果可以看出对象交换是成功的</span></div><div class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469648</span> <span class="comment">// 对象d构造</span></div><div class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469680</span> <span class="comment">// 对象e构造</span></div><div class="line">Move Constructor is called! src: <span class="number">38469648</span> <span class="comment">// swap函数中的对象c通过移动构造函数构造</span></div><div class="line">Move Operator= is called! src: <span class="number">38469680</span> <span class="comment">// swap函数中的对象a通过移动赋值操作符赋值</span></div><div class="line">Move Operator= is called! src: <span class="number">38469648</span> <span class="comment">// swap函数中的对象b通过移动赋值操作符赋值</span></div><div class="line">DeConstructor is called! <span class="comment">// swap函数中的对象c析构</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469648</span> <span class="comment">// 对象e析构</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469680</span> <span class="comment">// 对象d析构</span></div></pre></td></tr></table></figure>
<h1 id="右值引用和右值的关系"><a href="#右值引用和右值的关系" class="headerlink" title="右值引用和右值的关系"></a>右值引用和右值的关系</h1><p>这个问题就有点绕了，需要开动思考一下右值引用和右值是啥含义了。读者会凭空的认为右值引用肯定是右值，其实不然。我们在之前的例子中添加如下代码，并将main函数进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_rvalue_rref</span><span class="params">(MyString &amp;&amp;str)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"tmp object construct start"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    MyString tmp = str;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"tmp object construct finish"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    test_rvalue_rref(foo());</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出结果</span></div><div class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913680</span></div><div class="line">Move Constructor is called! src: <span class="number">28913680</span></div><div class="line">DeConstructor is called!</div><div class="line">tmp object construct start</div><div class="line">Copy Constructor is called! src: <span class="number">28913680</span> dst: <span class="number">28913712</span> <span class="comment">// 可以看到这里调用的是复制构造函数而不是移动构造函数</span></div><div class="line">tmp object construct finish</div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913712</span></div><div class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913680</span></div></pre></td></tr></table></figure>
<p>我想程序运行的结果肯定跟大多数人想到的不一样，“Are you kidding me?不是应该调用移动构造函数吗？为什么调用了复制构造函数？”。关于右值引用和左右值之间的规则是：</p>
<blockquote>
<p>如果右值引用有名字则为左值，如果右值引用没有名字则为右值。</p>
</blockquote>
<p>通过规则我们可以发现，在我们的例子中右值引用str是有名字的，因此为左值，tmp的构造会调用复制构造函数。之所以会这样，是因为如果tmp构造的时候调用了移动构造函数，则调用完成后str的申请的内存自己已经不可用了，如果在该函数中该语句的后面在调用str变量会出现我们意想不到的问题。鉴于此，我们也就能够理解为什么有名字的右值引用是左值了。如果已经确定在tmp构造语句的后面不需要使用str变量了，可以使用std::move()函数将str变量从左值转换为右值，这样tmp变量的构造就可以使用移动构造函数了。</p>
<p>而如果我们调用的是<code>MyString b = foo()</code>语句，由于foo()函数返回的是临时对象没有名字属于右值，因此b的构造会调用移动构造函数。</p>
<p>该规则非常的重要，要想能够正确使用右值引用，该规则必须要掌握，否则写出来的代码会有一个大坑。</p>
<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><p>前面已经介绍了本文的两大主题之一的移动语义，还剩下完美转发机制。完美转发机制通常用于库函数中，至少在我的工作中还是很少使用的。如果实在不想理解该问题，可以不用向下看了。在泛型编程中，经常会遇到的一个问题是怎样将一组参数原封不动的转发给另外一个函数。这里的原封不动是指，如果函数是左值，那么转发给的那个函数也要接收一个左值；如果参数是右值，那么转发给的函数也要接收一个右值；如果参数是const的，转发给的函数也要接收一个const参数；如果参数是非const的，转发给的函数也要接收一个非const值。</p>
<p>该问题看上去非常简单，其实不然。看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;&amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T t)</span> </span>&#123; fun(t); &#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    PerfectForward(<span class="number">10</span>);           <span class="comment">// rvalue ref</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    PerfectForward(a);            <span class="comment">// lvalue ref</span></div><div class="line">    PerfectForward(<span class="built_in">std</span>::move(a)); <span class="comment">// rvalue ref</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">8</span>;</div><div class="line">    PerfectForward(b);            <span class="comment">// const lvalue ref</span></div><div class="line">    PerfectForward(<span class="built_in">std</span>::move(b)); <span class="comment">// const rvalue ref</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述例子中，我们想达到的目的是PerfectForward模板函数能够完美转发参数t到fun函数中。上述例子中的PerfectForward函数必然不能够达到此目的，因为PerfectForward函数的参数为左值类型，调用的fun函数也必然为<code>void fun(int &amp;)</code>。且调用PerfectForward之前就产生了一次参数的复制操作，因此这样的转发只能称之为正确转发，而不是完美转发。要想达到完美转发，需要做到像转发函数不存在一样的效率。</p>
<p>因此，我们考虑将PerfectForward函数的参数更改为引用类型，因为引用类型不会有额外的开销。另外，还需要考虑转发函数PerfectForward是否可以接收引用类型。如果转发函数PerfectForward仅能接收左值引用或右值引用的一种，那么也无法实现完美转发。</p>
<p>我们考虑使用<code>const T &amp;t</code>类型的参数，因为我们在前文中提到过，const左值引用类型可以绑定到任何类型。但是这样目标函数就不一定能接收const左值引用类型的参数了。const左值引用属于左值，非const左值引用和非const右值引用是无法绑定到const左值的。</p>
<p>如果将参数t更改为非const右值引用、const右值也是不可以实现完美转发的。</p>
<p>在C++11中为了能够解决完美转发问题，引入了更为复杂的规则：引用折叠规则和特殊模板参数推导规则。</p>
<h2 id="引用折叠推导规则"><a href="#引用折叠推导规则" class="headerlink" title="引用折叠推导规则"></a>引用折叠推导规则</h2><p>为了能够理解清楚引用折叠规则，还是通过以下例子来学习。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp; TR;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> &amp;b = a;</div><div class="line">    <span class="keyword">int</span> &amp; &amp;c = a;  <span class="comment">// 编译器报错，不可以对引用再显示添加引用</span></div><div class="line">    TR &amp;d = a;     <span class="comment">// 通过typedef定义的类型隐式添加引用是可以的</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在C++中，不可以在程序中对引用再显示添加引用类型，对于<code>int &amp; &amp;c</code>的声明变量方式，编译器会提示错误。但是如果在上下文中（包括使用模板实例化、typedef、auto类型推断等）出现了对引用类型再添加引用的情况，编译器是可以编译通过的。具体的引用折叠规则如下，可以看出一旦引用中定义了左值类型，折叠规则总是将其折叠为左值引用。这就是引用折叠规则的全部内容了。另外折叠规则跟变量的const特性是没有关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A&amp; &amp; =&gt; A&amp;</div><div class="line">A&amp; &amp;&amp; =&gt; A&amp;</div><div class="line">A&amp;&amp; &amp; =&gt; A&amp;</div><div class="line">A&amp;&amp; &amp;&amp; =&gt; A&amp;&amp;</div></pre></td></tr></table></figure>
<h2 id="特殊模板参数推导规则"><a href="#特殊模板参数推导规则" class="headerlink" title="特殊模板参数推导规则"></a>特殊模板参数推导规则</h2><p>下面我们再来学习特殊模板参数推导规则，考虑下面的模板函数，模板函数接收一个右值引用作为模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp;)</span></span>;</div></pre></td></tr></table></figure>
<p>说白点，特殊模板参数推导规则其实就是引用折叠规则在模板参数为右值引用时模板情况下的应用，是引用折叠规则的一种情况。我们结合上文中的引用折叠规则，</p>
<ol>
<li>如果foo的实参是上文中的A类型的左值时，T的类型就为A&amp;。根据引用折叠规则，最后foo的参数类型为A&amp;。</li>
<li>如果foo的实参是上文中的A类型的右值时，T的类型就为A&amp;&amp;。根据引用折叠规则，最后foo的参数类型为A&amp;&amp;。</li>
</ol>
<h2 id="解决完美转发问题"><a href="#解决完美转发问题" class="headerlink" title="解决完美转发问题"></a>解决完美转发问题</h2><p>我们已经学习了模板参数为右值引用时的特殊模板参数推导规则，那么我们利用刚学习的知识来解决本文中待解决的完美转发的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;&amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">//template&lt;typename T&gt;</span></div><div class="line"><span class="comment">//void PerfectForward(T t) &#123; fun(t); &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 利用引用折叠规则代替了原有的不完美转发机制</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; fun(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(t)); &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    PerfectForward(<span class="number">10</span>);           <span class="comment">// rvalue ref，折叠后t类型仍然为T &amp;&amp;</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    PerfectForward(a);            <span class="comment">// lvalue ref，折叠后t类型为T &amp;</span></div><div class="line">    PerfectForward(<span class="built_in">std</span>::move(a)); <span class="comment">// rvalue ref，折叠后t类型为T &amp;&amp;</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">8</span>;</div><div class="line">    PerfectForward(b);            <span class="comment">// const lvalue ref，折叠后t类型为const T &amp;</span></div><div class="line">    PerfectForward(<span class="built_in">std</span>::move(b)); <span class="comment">// const rvalue ref，折叠后t类型为const T &amp;&amp;</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中已经对完美转发的各种情况进行了说明，这里需要对PerfectForward模板函数中的static_cast进行说明。static_cast仅是对传递右值时起作用。我们看一下当参数为右值时的情况，这里的右值包括了const右值和非const右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数为右值，引用折叠规则引用前</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> &amp;&amp; &amp;&amp;T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(<span class="keyword">int</span> &amp;&amp; &amp;&amp;t)</span> </span>&#123; fun(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> &amp;&amp; &amp;&amp;&gt;(t)); &#125;</div><div class="line"></div><div class="line"><span class="comment">// 引用折叠规则应用后</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> &amp;&amp;T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(<span class="keyword">int</span> &amp;&amp;t)</span> </span>&#123; fun(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> &amp;&amp;&gt;(t)); &#125;</div></pre></td></tr></table></figure>
<p>可能读者仍然没有发现上述例子中的问题，“不用static_cast进行强制类型转换不是也可以吗？”。别忘记前文中仍然提到一个右值引用和右值之间关系的规则，<code>如果右值引用有名字则为左值，如果右值引用没有名字则为右值。</code>。这里的变量t虽然为右值引用，但是是左值。如果我们想继续向fun函数中传递右值，就需要使用static_cast进行强制类型转换了。</p>
<p>其实在C++11中已经为我们封装了std::forward函数来替代我们上文中使用的static_cast类型转换，该例子中使用std::forward函数的版本变为了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; fun(<span class="built_in">std</span>::forward&lt;T&gt;(t)); &#125;</div></pre></td></tr></table></figure>
<p>对于上文中std::move函数的实现也是使用了引用折叠规则，实现方式跟std::forward一致。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol>
<li>《深入理解C++11-C++11新特性解析与应用》</li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/" target="_blank" rel="external">C++11 标准新特性: 右值引用与转移语义</a></li>
<li><a href="http://www.zhihu.com/question/22111546" target="_blank" rel="external">如何评价 C++11 的右值引用（Rvalue reference）特性？</a></li>
<li><a href="http://blog.bitdewy.me/blog/2013/07/08/cpp11-perfect-forward/" target="_blank" rel="external">C++11 完美转发</a></li>
<li><a href="http://thbecker.net/articles/rvalue_references/section_01.html#section_01" target="_blank" rel="external">C++ Rvalue References Explained</a></li>
<li><a href="http://jxq.me/2012/06/06/%E8%AF%91%E8%AF%A6%E8%A7%A3c%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" target="_blank" rel="external">详解C++右值引用</a> （对C++ Rvalue References Explained的翻译）</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/large_website_architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/large_website_architecture/" itemprop="url">
                  大型网站技术架构读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-13T00:00:00+08:00">
                2015-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近粗读了一遍《大型网站技术架构-核心原理与案例分析》，并对其中的内容通过思维导图的形式进行了整理。本书的所讲解的内容均为大型网站中涉及到的问题及相关技术，但并未展开深入讨论相关技术的解决办法，非常适合入门。下面我将我的思维导图以图片的形式贴出来，并提供XMind编辑的.xmid格式的文件。</p>
<p><img src="http://kuring.qiniudn.com/large_website_architecture.png" alt=""></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="http://pan.baidu.com/s/1lngiq" target="_blank" rel="external">大型网站技术架构读书笔记</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/airodump-ng_ssid_messy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/airodump-ng_ssid_messy/" itemprop="url">
                  解决airodump-ng显示ssid名称的乱码问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-04T00:00:00+08:00">
                2015-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>无线wifi的essid支持英文和中文，中文的编码在802.11协议并没有规定，对于802.11协议而言仅将essid看作是二进制。而中文又存在多种编码方式，最常见的就是GB18030（我这里直接用GB18030代替了GB系列的字符集）和UTF-8了。</p>
<p>iwlist程序通过命令<code>iwlist wlan0 scanning</code>可以在终端上正常显示UTF-8编码的essid，对于其他编码的中文仍然是乱码，这也就非常容易理解了。因为具体的essid能否将中文正常显示在终端屏幕上跟essid的编码和当前终端环境的编码是否能够匹配有关，如果essid的编码和当前终端环境的编码均为UTF-8，则essid可以在屏幕上正常显示。如果当前网络中的可以搜索到的essid即包含了GB18030编码又包含了UTF-8编码，则打印在终端上的essid必然会有乱码的情况出现。</p>
<h1 id="airodump-ng程序问题"><a href="#airodump-ng程序问题" class="headerlink" title="airodump-ng程序问题"></a>airodump-ng程序问题</h1><p>对于airodump-ng程序而言，即时是essid的编码和终端编码一致也会出现某些中文字符乱码的问题，这一点比较奇怪。比如“免费”中的“免”字是乱码，“费”却能正常显示。通过这一现象有理由怀疑airodump-ng对essid做了某些处理。</p>
<p>经过查看源码发现，在airodump-ng.c文件中存在三处如下类似代码，作用为将essid中的ascii值在(126,160)之间的转换为”.”。看来airodump-ng程序并没有考虑到中文的情况，仅将ascii中无法显示的字符做了转换。将程序中的三处代码注释后就可以正常显示了。具体三处代码可以通过搜索’.’来查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</div><div class="line">&#123;</div><div class="line">	c = p[<span class="number">2</span> + i];</div><div class="line">	<span class="keyword">if</span>( c == <span class="number">0</span> || ( c &gt; <span class="number">126</span> &amp;&amp; c &lt; <span class="number">160</span> ) )</div><div class="line">	&#123;</div><div class="line">		c = <span class="string">'.'</span>;  <span class="comment">//could also check ||(c&gt;0 &amp;&amp; c&lt;32)</span></div><div class="line">	&#125;</div><div class="line">	st_cur-&gt;probes[st_cur-&gt;probe_index][i] = c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="NetworkManager"><a href="#NetworkManager" class="headerlink" title="NetworkManager"></a>NetworkManager</h1><p>通过实践发现，GNOME和KDE桌面下的查看无线网络连接的ssid是可以正常显示的，即可以正常显示GB18030，又可以正常显示UTF-8编码的essid。则可以推测，在桌面环境下的搜索网络的程序肯定对编码做了某些处理，顺着这个思路，就可以查找GNOME或KDE的代码了。</p>
<p>在GNOME的源码中看到了network-manager-applet，该程序即为桌面上查看无线网络连接的小控件。在applet-device-wifi.c文件中看到了如下代码，其中的<code>nm_utils_ssid_to_utf8</code>函数即为将其他编码转换为UTF-8编码的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *</span></div><div class="line"><span class="title">get_ssid_utf8</span> <span class="params">(NMAccessPoint *ap)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> *ssid_utf8 = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">const</span> GByteArray *ssid;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (ap) &#123;</div><div class="line">		ssid = nm_access_point_get_ssid (ap);</div><div class="line">		<span class="keyword">if</span> (ssid)</div><div class="line">			ssid_utf8 = nm_utils_ssid_to_utf8 (ssid);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (!ssid_utf8)</div><div class="line">		ssid_utf8 = g_strdup (_(<span class="string">"(none)"</span>));</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ssid_utf8;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>nm_utils_ssid_to_utf8</code>函数定义在NetworkManager工程中的nm-utils.c文件中。该函数的代码如下，该函数具体功能可以查看代码中的注释，已经非常详细了。其中以<code>g_</code>开头的函数是glib库中的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *</span></div><div class="line"><span class="title">nm_utils_ssid_to_utf8</span> <span class="params">(<span class="keyword">const</span> GByteArray *ssid)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> *converted = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span> *lang, *e1 = <span class="literal">NULL</span>, *e2 = <span class="literal">NULL</span>, *e3 = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	g_return_val_if_fail (ssid != <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (g_utf8_validate ((<span class="keyword">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="literal">NULL</span>))</div><div class="line">		<span class="keyword">return</span> g_strndup ((<span class="keyword">const</span> gchar *) ssid-&gt;data, ssid-&gt;len);</div><div class="line"></div><div class="line">	<span class="comment">/* LANG may be a good encoding hint */</span></div><div class="line">	g_get_charset ((<span class="keyword">const</span> <span class="keyword">char</span> **)(&amp;e1));</div><div class="line">	<span class="keyword">if</span> ((lang = getenv (<span class="string">"LANG"</span>))) &#123;</div><div class="line">		<span class="keyword">char</span> * dot;</div><div class="line"></div><div class="line">		lang = g_ascii_strdown (lang, <span class="number">-1</span>);</div><div class="line">		<span class="keyword">if</span> ((dot = <span class="built_in">strchr</span> (lang, <span class="string">'.'</span>)))</div><div class="line">			*dot = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">		get_encodings_for_lang (lang, &amp;e1, &amp;e2, &amp;e3);</div><div class="line">		g_free (lang);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	converted = g_convert ((<span class="keyword">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">"UTF-8"</span>, e1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!converted &amp;&amp; e2)</div><div class="line">		converted = g_convert ((<span class="keyword">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">"UTF-8"</span>, e2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!converted &amp;&amp; e3)</div><div class="line">		converted = g_convert ((<span class="keyword">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">"UTF-8"</span>, e3, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!converted) &#123;</div><div class="line">		converted = g_convert_with_fallback ((<span class="keyword">const</span> gchar *) ssid-&gt;data, ssid-&gt;len,</div><div class="line">		                                     <span class="string">"UTF-8"</span>, e1, <span class="string">"?"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> converted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>nm_utils_ssid_to_utf8该函数位于libnm-util.so.1动态库中，可通过<code>nm -D  /usr/lib64/libnm-util.so.1 | grep nm_utils_ssid_to_utf8</code>命令查看导出表中存在该函数。但是系统中并不存在该函数的头文件libnm-util.h，给该库的调用增加了不少难度。可以通过将相关头文件引入到该工程编译的方式来完成，但是可能会牵涉到的头文件比较多，比较繁琐。</p>
<p>我这里直接采用了将NetworkManager中相关代码抓取出来的思路，并将其封装成类的形式以方便调用。具体代码可以参照demo中的例子。</p>
<h1 id="glib"><a href="#glib" class="headerlink" title="glib"></a>glib</h1><p>glib是GTK底层调用的核心库，跟glibc是没有关系的，虽然名字中仅差一个字母。为了调用该库需要在编译的时候添加<em><code>pkg-config --cflags --libs glib-2.0</code></em>信息，以引入需要的头文件和要链接的库。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/1qWqjMCc" target="_blank" rel="external">文中用到的软件源码和程序demo</a></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://git.gnome.org/browse/" target="_blank" rel="external">GNOME源码列表</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/single_number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/single_number/" itemprop="url">
                  leetcode题目之Single Number
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-31T00:00:00+08:00">
                2015-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目一-Single-Number"><a href="#题目一-Single-Number" class="headerlink" title="题目一 Single Number"></a>题目一 Single Number</h1><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h1 id="题目二-Single-Number-II"><a href="#题目二-Single-Number-II" class="headerlink" title="题目二 Single Number II"></a>题目二 Single Number II</h1><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h1 id="题目一分析及解答"><a href="#题目一分析及解答" class="headerlink" title="题目一分析及解答"></a>题目一分析及解答</h1><p>针对题目一，一看就能看出是考察异或操作的特点，并迅速写出了解答方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        &#123;   </div><div class="line">            result ^= A[i];</div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="题目二分析及解答"><a href="#题目二分析及解答" class="headerlink" title="题目二分析及解答"></a>题目二分析及解答</h1><p>要想实现时间复杂度为O(n)，空间复杂度为O(1)的算法，还是跟题目一一样需要充分利用位操作特性，但是并没有直接可用的位操作特性可以完成，于是想到肯定是各种位操作的组合操作，但是并没有继续向下想到具体的算法。本质上该题目就是模拟一个三进制的操作，当一个位的最大值为2，当为3时直接清0。</p>
<p>参照网上的算法，利用一个int类型的数组来模拟一个三进制数，每个int值的最大值为3，当然这样存在一定空间上的浪费。算法需要将A中的每个值通过移位运算获取到该位的状态，并将值添加到用来模拟三进制的int数组中相应的位置，最后将模拟三进制int数组中的值为3的更改为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++&#123;</div><div class="line">                <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</div><div class="line">                    count[i]++;</div><div class="line">                &#125;   </div><div class="line">            &#125;   </div><div class="line">            result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i); </div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另外，还有上述算法的改进算法，更为节省空间，效率更高，但是确实不容易理解和记忆，属于下次仍然无法记忆的算法类型。这里仅提供代码，不再给出解释，自己领悟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        twos |= ones &amp; A[i];</div><div class="line">        ones ^= A[i];<span class="comment">// 异或3次 和 异或 1次的结果是一样的</span></div><div class="line">       <span class="comment">//对于ones 和 twos 把出现了3次的位置设置为0 （取反之后1的位置为0）</span></div><div class="line">        threes = ones &amp; twos;</div><div class="line">        ones &amp;= ~threes;</div><div class="line">        twos &amp;= ~threes;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/nowcoder_2015.3.12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/nowcoder_2015.3.12/" itemprop="url">
                  牛客网内推笔试卷题目2015.3.12
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-25T00:00:00+08:00">
                2015-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间参加了牛客网的答题活动，共两套试题，每套题目3个算法题，我只做了每套题的前两道。最近想查看之前做的题目的答案，却发现非常不方便，特此将我做过的4道题目记录一下，算法的思路就不再解释了。</p>
<h1 id="题目一-奇数位上都是奇数或者偶数位上都是偶数"><a href="#题目一-奇数位上都是奇数或者偶数位上都是偶数" class="headerlink" title="题目一 奇数位上都是奇数或者偶数位上都是偶数"></a>题目一 奇数位上都是奇数或者偶数位上都是偶数</h1><blockquote>
<p>给定一个长度不小于2的数组arr。 写一个函数调整arr，使arr中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),下标0,2,4,6…算作偶数位,下标1,3,5,7…算作奇数位，例如[1,2,3,4]调整为[2,1,4,3]即可。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oddInOddEvenInEven</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> odd = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> even = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (odd &lt; len &amp;&amp; even &lt; len)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (arr[odd] % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (arr[even] % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    even += <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (even &lt; len)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">int</span> tmp = arr[even];</div><div class="line">                    arr[even] = arr[odd];</div><div class="line">                    arr[odd] = tmp;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                odd += <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="题目二-求正数数组的最小不可组成和"><a href="#题目二-求正数数组的最小不可组成和" class="headerlink" title="题目二 求正数数组的最小不可组成和"></a>题目二 求正数数组的最小不可组成和</h1><blockquote>
<p>给定一个全是正数的数组arr，定义一下arr的最小不可组成和的概念： 1，arr的所有非空子集中，把每个子集内的所有元素加起来会出现很多的值，其中最小的记为min，最大的记为max； 2，在区间[min,max]上，如果有一些正数不可以被arr某一个子集相加得到，那么这些正数中最小的那个，就是arr的最小不可组成和； 3，在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和； 举例： arr = {3,2,5} arr的min为2，max为10，在区间[2,10]上，4是不能被任何一个子集相加得到的值中最小的，所以4是arr的最小不可组成和； arr = {3,2,4} arr的min为2，max为9，在区间[2,9]上，8是不能被任何一个子集相加得到的值中最小的，所以8是arr的最小不可组成和； arr = {3,1,2} arr的min为1，max为6，在区间[2,6]上，任何数都可以被某一个子集相加得到，所以7是arr的最小不可组成和； 请写函数返回arr的最小不可组成和。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirstUnFormedNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp = res;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = res.begin(); iter != res.end(); iter++)</div><div class="line">            &#123;</div><div class="line">                tmp.insert(*iter + arr[i]);</div><div class="line">            &#125;</div><div class="line">            res = tmp;</div><div class="line">            res.insert(arr[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = res.begin();</div><div class="line">        <span class="keyword">int</span> before = *iter;</div><div class="line">        iter++;</div><div class="line">        <span class="keyword">for</span> (; iter != res.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (*iter - before &gt; <span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> before + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            before = *iter;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> before + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="题目三-最大的LeftMax与rightMax之差绝对值"><a href="#题目三-最大的LeftMax与rightMax之差绝对值" class="headerlink" title="题目三 最大的LeftMax与rightMax之差绝对值"></a>题目三 最大的LeftMax与rightMax之差绝对值</h1><blockquote>
<p>给定一个长度为N的整型数组arr，可以划分成左右两个部分： 左部分arr[0..K]，右部分arr[K+1..arr.length-1]，K可以取值的范围是[0,arr.length-2] 求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？ 例如： [2,7,3,1,1] 当左部分为[2,7]，右部分为[3,1,1]时，左部分中的最大值减去右部分最大值的绝对值为4; 当左部分为[2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6; 最后返回的结果为6。 注意：如果数组的长度为N，请尽量做到时间复杂度O(N)，额外空间复杂度O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxABSLeftAndRight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// find the max in array</span></div><div class="line">        <span class="keyword">int</span> max = vec[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;(<span class="keyword">int</span>)vec.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (vec[i] &gt; max)</div><div class="line">            &#123;</div><div class="line">                max = vec[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// compare the head and tail in array</span></div><div class="line">        <span class="keyword">if</span> (vec[<span class="number">0</span>] &lt; vec[len - <span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> max - vec[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max - vec[len - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="题目四-按照左右半区的方式重新组合单链表"><a href="#题目四-按照左右半区的方式重新组合单链表" class="headerlink" title="题目四 按照左右半区的方式重新组合单链表"></a>题目四 按照左右半区的方式重新组合单链表</h1><blockquote>
<p>给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区； 如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区； 左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…。请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的样子。 例如： 1-&gt;2-&gt;3-&gt;4 调整后：1-&gt;3-&gt;2-&gt;4 1-&gt;2-&gt;3-&gt;4-&gt;5 调整后：1-&gt;3-&gt;2-&gt;4-&gt;5 要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relocateList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// use one loop, find the right head</span></div><div class="line">        ListNode *right_head = head;</div><div class="line">        ListNode *node = head;</div><div class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (node-&gt;next == <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (node-&gt;next-&gt;next == <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                right_head = right_head-&gt;next;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            right_head = right_head-&gt;next;</div><div class="line">            node = node-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode *left_node = head;</div><div class="line">        ListNode *right_node = right_head;</div><div class="line">        <span class="keyword">while</span> (left_node-&gt;next != right_head)</div><div class="line">        &#123;</div><div class="line">            ListNode *tmp = left_node-&gt;next;</div><div class="line">            left_node-&gt;next = right_node;</div><div class="line">            right_node = right_node-&gt;next;</div><div class="line">            left_node-&gt;next-&gt;next = tmp;</div><div class="line">            left_node = left_node-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        left_node-&gt;next = right_node;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/majority_element/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kuring Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只特立独行的鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/majority_element/" itemprop="url">
                  leetcode题目之Majority Element
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-11T00:00:00+08:00">
                2015-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.<br>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题是一道非常简单的题目，但我能想到的思路有限，仅能想到排序法和哈希法两种算法，在Solution中提供了另外几种方法，这是非常值得我学习和思考的。本文仅将网站的思路拿过来，可以直接看该问题的<a href="https://leetcode.com/problems/majority-element/solution/" target="_blank" rel="external">Solution</a>。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h2><p>最原始的解决办法，逐个元素比较是否为该数组中的最多元素，只要满足条件即可终止。时间复杂度为O(n^2)。</p>
<h2 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h2><p>将数组中的元素遍历一遍，并将数组中元素的个数保存到哈希中。然后遍历哈希，从哈希中找到最多元素。时间复杂度O(n)，但需要占用一定的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; result_map;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = num.begin(); iter != num.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (result_map.find(*iter) == result_map.end())</div><div class="line">            &#123;</div><div class="line">                result_map.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(*iter, <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                result_map[*iter]++;                                                                                                                                            </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> max_count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> result;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = result_map.begin(); iter != result_map.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; max_count)</div><div class="line">            &#123;</div><div class="line">                result = iter-&gt;first;</div><div class="line">                max_count = iter-&gt;second;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>直接对元素进行排序，排序后元素的中间元素即为要求的最多元素。时间复杂度为O(nlogn)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElementSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">   sort(num.begin(), num.end());</div><div class="line">   <span class="keyword">return</span> num[num.size() / <span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="随机抽取法"><a href="#随机抽取法" class="headerlink" title="随机抽取法"></a>随机抽取法</h2><p>随机从数组中抽取元素，然后遍历数组判断该元素是否为最多元素。该算法利用了最多元素被随机抽取的概率最大的特点，但该算法效率的随机性较大，最好时间复杂度为O(n)，最坏情况下一直随机不到最多元素。</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>将数组均分为两份，分别求出两个数组中的最多元素A和B，则整个数组中的最多元素必然在两个子数组的最多元素A和B中，这一点可以通过举例子的方式来证明，但是仅凭感觉不太容易得出该结论。如果A==B，则结果就是A。如果A!=B，则分别求出A和B在这个数组中的元素个数。时间复杂度接近O(nlogn)。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些比较不容易想到的算法，这里就不列举了。至少我看过一次之后，下次这些算法仍然是记不住的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kuring Lyu" />
          <p class="site-author-name" itemprop="name">Kuring Lyu</p>
           
              <p class="site-description motion-element" itemprop="description">一只特立独行的鸟</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">106</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/kuring" title="Github地址" target="_blank">Github地址</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://weibo.com/ilvkai" title="新浪微博" target="_blank">新浪微博</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kuring Lyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
